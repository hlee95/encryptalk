C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE USBUART
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Debug\USBUART.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\USBUART.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB WL(2) PR(
                    -.\DP8051_Keil_951\Debug/USBUART.lst) CD OT(2,SIZE) OJ(.\DP8051_Keil_951\Debug\USBUART.obj)

line level    source

   1          /***************************************************************************//**
   2          * \file USBUART.c
   3          * \version 3.0
   4          *
   5          * \brief
   6          *  This file contains the global USBFS API functions.
   7          *
   8          * Note:
   9          *  Many of the functions use an endpoint number. SRAM arrays are sized with 9
  10          *  elements, so they are indexed directly by epNumber.  The SIE and ARB
  11          *  registers are indexed by variations of epNumber - 1.
  12          *
  13          ********************************************************************************
  14          * \copyright
  15          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  16          * You may use this file only in accordance with the license, terms, conditions,
  17          * disclaimers, and limitations in the end user license agreement accompanying
  18          * the software package with which this file was provided.
  19          *******************************************************************************/
  20          
  21          #include "USBUART_pvt.h"
  22          #include "USBUART_cydmac.h"
  23          #include "USBUART_hid.h"
  24          
  25          
  26          /***************************************
  27          * Global data allocation
  28          ***************************************/
  29          
  30          /** Indicates whether the USBFS has been initialized. The variable is
  31          * initialized to 0 after device reset and set to 1 the first time USBFS_Start()
  32          * is called. This allows the Component to restart without reinitialization after
  33          * the first call to the USBFS_Start() routine.
  34          * If re-initialization of the Component is required, the variable should be set
  35          * to 0 before the USBFS_Start() routine is called. Alternatively, the USBFS can
  36          * be reinitialized by calling both USBFS_Init() and USBFS_InitComponent()
  37          * functions.
  38          */
  39          uint8 USBUART_initVar = 0u;
  40          
  41          #if (USBUART_EP_MANAGEMENT_DMA)
                  #if (CY_PSOC4)
                      static void USBUART_InitEpDma(void);
              
                      /* DMA chanels assigend for endpoints. */
                      const uint8 USBUART_DmaChan[USBUART_MAX_EP] =
                      {
                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 2   

                          0u,
                          0u,
                          0u,
                      };        
                  #else
                      /* DMA chanels assigend for endpoints. */
                      uint8 USBUART_DmaChan[USBUART_MAX_EP];
                      
                      /* DMA TDs require for PSoC 3/5LP operation. */
                      uint8 USBUART_DmaTd[USBUART_MAX_EP];
                  #endif /* (CY_PSOC4) */
              #endif /* (USBUART_EP_MANAGEMENT_DMA) */
  66          
  67          #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
              #if (CY_PSOC4)
                  /* Number of DMA bursts. */
                  uint8  USBUART_DmaEpBurstCnt   [USBUART_MAX_EP];
                  
                  /* Number of bytes to transfer in last DMA burst. */
                  uint8  USBUART_DmaEpLastBurstEl[USBUART_MAX_EP];
              
                  /* Storage for arrays above. */
                  uint8  USBUART_DmaEpBurstCntBackup  [USBUART_MAX_EP];
                  uint32 USBUART_DmaEpBufferAddrBackup[USBUART_MAX_EP];
                   
                  /* DMA trigger mux output for usb.dma_req[0-7]. */
                  const uint8 USBUART_DmaReqOut[USBUART_MAX_EP] =
                  {
                      0u,
                      USBUART_ep1_dma__TR_OUTPUT,
                      USBUART_ep2_dma__TR_OUTPUT,
                      USBUART_ep3_dma__TR_OUTPUT,
                      0u,
                      0u,
                      0u,
                      0u,
                      0u,
                  };
              
                  /* DMA trigger mux output for usb.dma_burstend[0-7]. */
                  const uint8 USBUART_DmaBurstEndOut[USBUART_MAX_EP] =
                  {
                      0u,
                      USBUART_BURSTEND_0_TR_OUTPUT,
                      USBUART_BURSTEND_1_TR_OUTPUT,
                      USBUART_BURSTEND_2_TR_OUTPUT,
                      USBUART_BURSTEND_3_TR_OUTPUT,
                      USBUART_BURSTEND_4_TR_OUTPUT,
                      USBUART_BURSTEND_5_TR_OUTPUT,
                      USBUART_BURSTEND_6_TR_OUTPUT,
                      USBUART_BURSTEND_7_TR_OUTPUT
                  };
                  
              #else
                  #if (USBUART_EP_DMA_AUTO_OPT == 0u)
                      static uint8 clearInDataRdyStatus = USBUART_ARB_EPX_CFG_DEFAULT;
                      uint8 USBUART_DmaNextTd[USBUART_MAX_EP];
                      const uint8 USBUART_epX_TD_TERMOUT_EN[USBUART_MAX_EP] =
                      {
                          0u,
                          0u,
                          0u,
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 3   

                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
                      };
              
                      volatile uint16 USBUART_inLength[USBUART_MAX_EP];
                      const uint8 *USBUART_inDataPointer[USBUART_MAX_EP];
                      volatile uint8 USBUART_inBufFull[USBUART_MAX_EP];
                  #endif /* (USBUART_EP_DMA_AUTO_OPT == 0u) */
              #endif /* (CY_PSOC4) */
              #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
 130          
 131          
 132          /*******************************************************************************
 133          * Function Name: USBUART_Start
 134          ****************************************************************************//**
 135          *
 136          *   This function performs all required initialization for the USBFS component.
 137          *   After this function call, the USB device initiates communication with the
 138          *   host by pull-up D+ line. This is the preferred method to begin component
 139          *   operation.
 140          *
 141          *   Note that global interrupts have to be enabled because interrupts are
 142          *   required for USBFS component operation.
 143          *
 144          *   PSoC 4200L devices: when USBFS component configured to DMA with Automatic
 145          *   Buffer Management, the DMA interrupt priority is changed to the highest
 146          *   (priority 0) inside this function.
 147          *
 148          *   PSoC 3/PSoC 5LP devices: when USBFS component configured to DMA with
 149          *   Automatic Buffer Management, the Arbiter interrupt priority is changed to
 150          *   the highest (priority 0) inside this function.
 151          *
 152          *  \param device
 153          *          Contains the device number of the desired device descriptor.
 154          *          The device number can be found in the Device Descriptor Tab of
 155          *          "Configure" dialog, under the settings of desired Device Descriptor,
 156          *          in the "Device Number" field.
 157          *  \param mode:
 158          *   The operating voltage. This determines whether the voltage regulator
 159          *   is enabled for 5V operation or if pass through mode is used for 3.3V
 160          *   operation. Symbolic names and their associated values are given in the
 161          *   following list.
 162          *
 163          *       *USBUART_3V_OPERATION* - Disable voltage regulator and pass-
 164          *                                      through Vcc for pull-up
 165          *
 166          *       *USBUART_5V_OPERATION* - Enable voltage regulator and use
 167          *                                      regulator for pull-up
 168          *
 169          *       *USBUART_DWR_POWER_OPERATION* - Enable or disable the voltage
 170          *                                      regulator depending on the power supply
 171          *                                      voltage configuration in the DWR tab.
 172          *                                      For PSoC 3/5LP devices, the VDDD supply
 173          *                                      voltage is considered and for PSoC 4A-L,
 174          *                                      the VBUS supply voltage is considered.*
 175          * \globalvars
 176          *  \ref USBUART_initVar
 177          *
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 4   

 178          * \sideeffect
 179          *   This function will reset all communication states to default.
 180          *
 181          * \reentrant
 182          *  No.
 183          *
 184          *******************************************************************************/
 185          void USBUART_Start(uint8 device, uint8 mode) 
 186          {
 187   1          if (0u == USBUART_initVar)
 188   1          {
 189   2              USBUART_Init();
 190   2              USBUART_initVar = 1u;
 191   2          }
 192   1      
 193   1          USBUART_InitComponent(device, mode);
 194   1      }
 195          
 196          
 197          /*******************************************************************************
 198          * Function Name: USBUART_Init
 199          ****************************************************************************//**
 200          *
 201          * This function initializes or restores the component according to the
 202          * customizer Configure dialog settings. It is not necessary to call
 203          * USBUART_Init() because the USBUART_Start() routine calls
 204          * this function and is the preferred method to begin component operation.
 205          *
 206          * \reentrant
 207          *  No.
 208          *
 209          *******************************************************************************/
 210          void USBUART_Init(void) 
 211          {
 212   1      #if (CY_PSOC4)
                  /* Enable clock to USB IP. */
                  USBUART_USB_CLK_EN_REG = USBUART_USB_CLK_CSR_CLK_EN;
              
                  /* The internal regulator (CR1.REG_ENABLE) is enabled in
                  * USBUART_InitComponent() if it is required.
                  */
              
                  /* Enable USBIO control on drive mode of D+ and D- pins. */
                  USBUART_USBIO_CR1_REG &= ~ (uint32) USBUART_USBIO_CR1_IOMODE;
              
                  /* Set number of LF CLK to detect UBS bus reset. */
                  USBUART_BUS_RST_CNT_REG = USBUART_DEFUALT_BUS_RST_CNT;
              
                  /* Select VBUS detection source and clear PHY isolate. The application level
                  * must ensure that VBUS is valid. There is no need to wait 2us before VBUS is valid.
                  */
                  USBUART_POWER_CTRL_REG = USBUART_DEFAULT_POWER_CTRL_VBUS;
              
                  /* Enable PHY detector and single-ended and differential receivers. */
                  USBUART_POWER_CTRL_REG |= USBUART_DEFAULT_POWER_CTRL_PHY;
              
                  /* Suspend clear sequence. */
                  USBUART_POWER_CTRL_REG &= (uint32) ~USBUART_POWER_CTRL_SUSPEND;
                  CyDelayUs(USBUART_WAIT_SUSPEND_DEL_DISABLE);
                  USBUART_POWER_CTRL_REG &= (uint32) ~USBUART_POWER_CTRL_SUSPEND_DEL;
              
                  /* Sets IMO lock options and clear all other bits. */
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 5   

                  USBUART_CR1_REG = USBUART_DEFUALT_CR1;
              
                  /* Configure level (hi, lo, med) for each interrupt source. */
                  USBUART_INTR_LVL_SEL_REG = USBUART_DEFAULT_INTR_LVL_SEL;
              
                  /* Configure interrupt sources from: SOF, Bus Reset and EP0. */
                  USBUART_INTR_SIE_MASK_REG = USBUART_DEFAULT_INTR_SIE_MASK;
              
              #else
 249   1          uint8 enableInterrupts = CyEnterCriticalSection();
 250   1      
 251   1      #if (USBUART_EP_MANAGEMENT_DMA)
                  uint16 i;
              #endif /* (USBUART_EP_MANAGEMENT_DMA) */
 254   1      
 255   1          /* Enable USB block. */
 256   1          USBUART_PM_ACT_CFG_REG |= USBUART_PM_ACT_EN_FSUSB;
 257   1          /* Enable USB block for Standby Power Mode. */
 258   1          USBUART_PM_STBY_CFG_REG |= USBUART_PM_STBY_EN_FSUSB;
 259   1      
 260   1          /* Enable core clock. */
 261   1          USBUART_USB_CLK_EN_REG = USBUART_USB_CLK_ENABLE;
 262   1      
 263   1          USBUART_CR1_REG = USBUART_CR1_ENABLE_LOCK;
 264   1      
 265   1          /* ENABLING USBIO PADS IN USB MODE FROM I/O MODE. */
 266   1          /* Ensure USB transmit enable is low (USB_USBIO_CR0.ten). - Manual Transmission - Disabled. */
 267   1          USBUART_USBIO_CR0_REG &= (uint8) ~USBUART_USBIO_CR0_TEN;
 268   1          CyDelayUs(USBUART_WAIT_REG_STABILITY_50NS);  /* ~50ns delay. */
 269   1          /* Disable USBIO by asserting PM.USB_CR0.fsusbio_pd_n(Inverted.
 270   1          *  high. These bits will be set low by the power manager out-of-reset.
 271   1          *  Also confirm USBIO pull-up is disabled.
 272   1          */
 273   1          USBUART_PM_USB_CR0_REG &= (uint8) ~(USBUART_PM_USB_CR0_PD_N |
 274   1                                                       USBUART_PM_USB_CR0_PD_PULLUP_N);
 275   1      
 276   1          /* Select IOMODE to USB mode. */
 277   1          USBUART_USBIO_CR1_REG &= (uint8) ~USBUART_USBIO_CR1_IOMODE;
 278   1      
 279   1          /* Enable USBIO reference by setting PM.USB_CR0.fsusbio_ref_en. */
 280   1          USBUART_PM_USB_CR0_REG |= USBUART_PM_USB_CR0_REF_EN;
 281   1          /* Reference is available for 1us after regulator is enabled. */
 282   1          CyDelayUs(USBUART_WAIT_REG_STABILITY_1US);
 283   1          /* OR 40us after power is restored. */
 284   1          CyDelayUs(USBUART_WAIT_VREF_RESTORE);
 285   1          /* Ensure single-ended disable bits are low (PRT15.INP_DIS[7:6])(input receiver enabled). */
 286   1          USBUART_DM_INP_DIS_REG &= (uint8) ~USBUART_DM_MASK;
 287   1          USBUART_DP_INP_DIS_REG &= (uint8) ~USBUART_DP_MASK;
 288   1      
 289   1          /* Enable USBIO. */
 290   1          USBUART_PM_USB_CR0_REG |= USBUART_PM_USB_CR0_PD_N;
 291   1          CyDelayUs(USBUART_WAIT_PD_PULLUP_N_ENABLE);
 292   1          /* Set USBIO pull-up enable. */
 293   1          USBUART_PM_USB_CR0_REG |= USBUART_PM_USB_CR0_PD_PULLUP_N;
 294   1      
 295   1          /* Reset Arbiter Write Address register for endpoint 1. */
 296   1          CY_SET_REG8(USBUART_ARB_RW1_WA_PTR,     0u);
 297   1          CY_SET_REG8(USBUART_ARB_RW1_WA_MSB_PTR, 0u);
 298   1      
 299   1      #if (USBUART_EP_MANAGEMENT_DMA)
                  /* Initialize transfer descriptor. This will be used to detect DMA state - initialized or not. */
                  for (i = 0u; i < USBUART_MAX_EP; ++i)
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 6   

                  {
                      USBUART_DmaTd[i] = DMA_INVALID_TD;
              
                  #if (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u))
                      USBUART_DmaNextTd[i] = DMA_INVALID_TD;
                  #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u)) */
                  }
              #endif /* (USBUART_EP_MANAGEMENT_DMA) */
 310   1      
 311   1          CyExitCriticalSection(enableInterrupts);
 312   1      #endif /* (CY_PSOC4) */
 313   1      
 314   1          /* Configure interrupts from USB block. */
 315   1      #if (CY_PSOC4)
                  /* Configure hi_int: set handler and priority. */
                  CyIntSetPriority     (USBUART_INTR_HI_VECT_NUM,  USBUART_INTR_HI_PRIORITY);
                  (void) CyIntSetVector(USBUART_INTR_HI_VECT_NUM, &USBUART_INTR_HI_ISR);
              
                  /* Configure lo_int: set handler and priority. */
                  CyIntSetPriority     (USBUART_INTR_LO_VECT_NUM,  USBUART_INTR_LO_PRIORITY);
                  (void) CyIntSetVector(USBUART_INTR_LO_VECT_NUM, &USBUART_INTR_LO_ISR);
              
                  /* Configure med_int: set handler and priority (routed through DSI). */
                  CyIntSetPriority     (USBUART_INTR_MED_VECT_NUM,  USBUART_INTR_MED_PRIORITY);
                  (void) CyIntSetVector(USBUART_INTR_MED_VECT_NUM, &USBUART_INTR_MED_ISR);
              
              #else
 329   1          /* Set bus reset interrupt. */
 330   1          CyIntSetPriority(USBUART_BUS_RESET_VECT_NUM, USBUART_BUS_RESET_PRIOR);
 331   1          (void) CyIntSetVector(USBUART_BUS_RESET_VECT_NUM,   &USBUART_BUS_RESET_ISR);
 332   1      
 333   1          /* Set Control Endpoint Interrupt. */
 334   1          CyIntSetPriority(USBUART_EP_0_VECT_NUM, USBUART_EP_0_PRIOR);
 335   1          (void) CyIntSetVector(USBUART_EP_0_VECT_NUM,   &USBUART_EP_0_ISR);
 336   1      
 337   1          /* Set SOF interrupt. */
 338   1          #if (USBUART_SOF_ISR_ACTIVE)
 339   1              CyIntSetPriority     (USBUART_SOF_VECT_NUM,  USBUART_SOF_PRIOR);
 340   1              (void) CyIntSetVector(USBUART_SOF_VECT_NUM, &USBUART_SOF_ISR);
 341   1          #endif /* (USBUART_SOF_ISR_ACTIVE) */
 342   1      
 343   1          /* Set Data Endpoint 1 Interrupt. */
 344   1          #if (USBUART_EP1_ISR_ACTIVE)
 345   1              CyIntSetPriority     (USBUART_EP_1_VECT_NUM,  USBUART_EP_1_PRIOR);
 346   1              (void) CyIntSetVector(USBUART_EP_1_VECT_NUM,  &USBUART_EP_1_ISR);
 347   1          #endif /* (USBUART_EP1_ISR_ACTIVE) */
 348   1      
 349   1          /* Set Data Endpoint 2 Interrupt. */
 350   1          #if (USBUART_EP2_ISR_ACTIVE)
 351   1              CyIntSetPriority     (USBUART_EP_2_VECT_NUM,  USBUART_EP_2_PRIOR);
 352   1              (void) CyIntSetVector(USBUART_EP_2_VECT_NUM, &USBUART_EP_2_ISR);
 353   1          #endif /* (USBUART_EP2_ISR_ACTIVE) */
 354   1      
 355   1          /* Set Data Endpoint 3 Interrupt. */
 356   1          #if (USBUART_EP3_ISR_ACTIVE)
 357   1              CyIntSetPriority     (USBUART_EP_3_VECT_NUM,  USBUART_EP_3_PRIOR);
 358   1              (void) CyIntSetVector(USBUART_EP_3_VECT_NUM, &USBUART_EP_3_ISR);
 359   1          #endif /* (USBUART_EP3_ISR_ACTIVE) */
 360   1      
 361   1          /* Set Data Endpoint 4 Interrupt. */
 362   1          #if (USBUART_EP4_ISR_ACTIVE)
                      CyIntSetPriority     (USBUART_EP_4_VECT_NUM,  USBUART_EP_4_PRIOR);
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 7   

                      (void) CyIntSetVector(USBUART_EP_4_VECT_NUM, &USBUART_EP_4_ISR);
                  #endif /* (USBUART_EP4_ISR_ACTIVE) */
 366   1      
 367   1          /* Set Data Endpoint 5 Interrupt. */
 368   1          #if (USBUART_EP5_ISR_ACTIVE)
                      CyIntSetPriority     (USBUART_EP_5_VECT_NUM,  USBUART_EP_5_PRIOR);
                      (void) CyIntSetVector(USBUART_EP_5_VECT_NUM, &USBUART_EP_5_ISR);
                  #endif /* (USBUART_EP5_ISR_ACTIVE) */
 372   1      
 373   1          /* Set Data Endpoint 6 Interrupt. */
 374   1          #if (USBUART_EP6_ISR_ACTIVE)
                      CyIntSetPriority     (USBUART_EP_6_VECT_NUM,  USBUART_EP_6_PRIOR);
                      (void) CyIntSetVector(USBUART_EP_6_VECT_NUM, &USBUART_EP_6_ISR);
                  #endif /* (USBUART_EP6_ISR_ACTIVE) */
 378   1      
 379   1           /* Set Data Endpoint 7 Interrupt. */
 380   1          #if (USBUART_EP7_ISR_ACTIVE)
                      CyIntSetPriority     (USBUART_EP_7_VECT_NUM,  USBUART_EP_7_PRIOR);
                      (void) CyIntSetVector(USBUART_EP_7_VECT_NUM, &USBUART_EP_7_ISR);
                  #endif /* (USBUART_EP7_ISR_ACTIVE) */
 384   1      
 385   1          /* Set Data Endpoint 8 Interrupt. */
 386   1          #if (USBUART_EP8_ISR_ACTIVE)
                      CyIntSetPriority     (USBUART_EP_8_VECT_NUM,  USBUART_EP_8_PRIOR);
                      (void) CyIntSetVector(USBUART_EP_8_VECT_NUM, &USBUART_EP_8_ISR);
                  #endif /* (USBUART_EP8_ISR_ACTIVE) */
 390   1      
 391   1          /* Set ARB Interrupt. */
 392   1          #if (USBUART_EP_MANAGEMENT_DMA && USBUART_ARB_ISR_ACTIVE)
                      CyIntSetPriority     (USBUART_ARB_VECT_NUM,  USBUART_ARB_PRIOR);
                      (void) CyIntSetVector(USBUART_ARB_VECT_NUM, &USBUART_ARB_ISR);
                  #endif /* (USBUART_EP_MANAGEMENT_DMA && USBUART_ARB_ISR_ACTIVE) */
 396   1      #endif /* (CY_PSOC4) */
 397   1      
 398   1          /* Common: Configure GPIO interrupt for wakeup. */
 399   1      #if (USBUART_DP_ISR_ACTIVE)
 400   1          CyIntSetPriority     (USBUART_DP_INTC_VECT_NUM,  USBUART_DP_INTC_PRIORITY);
 401   1          (void) CyIntSetVector(USBUART_DP_INTC_VECT_NUM, &USBUART_DP_ISR);
 402   1      #endif /* (USBUART_DP_ISR_ACTIVE) */
 403   1      
 404   1      #if (USBUART_EP_MANAGEMENT_DMA && CY_PSOC4)
                  /* Initialize DMA channels. */
                  USBUART_InitEpDma();
              #endif /* (USBUART_EP_MANAGEMENT_DMA && CY_PSOC4) */
 408   1      }
 409          
 410          
 411          /*******************************************************************************
 412          * Function Name: USBUART_InitComponent
 413          ****************************************************************************//**
 414          *
 415          *   This function initializes the component’s global variables and initiates
 416          *   communication with the host by pull-up D+ line.
 417          *
 418          * \param device:
 419          *   Contains the device number of the desired device descriptor. The device
 420          *   number can be found in the Device Descriptor Tab of "Configure" dialog,
 421          *   under the settings of desired Device Descriptor, in the *Device Number*
 422          *   field.
 423          *  \param mode:
 424          *   The operating voltage. This determines whether the voltage regulator
 425          *   is enabled for 5V operation or if pass through mode is used for 3.3V
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 8   

 426          *   operation. Symbolic names and their associated values are given in the
 427          *   following list.
 428          *
 429          *       *USBUART_3V_OPERATION* - Disable voltage regulator and pass-
 430          *                                      through Vcc for pull-up
 431          *
 432          *       *USBUART_5V_OPERATION* - Enable voltage regulator and use
 433          *                                      regulator for pull-up
 434          *
 435          *       *USBUART_DWR_POWER_OPERATION* - Enable or disable the voltage
 436          *                                      regulator depending on the power supply
 437          *                                      voltage configuration in the DWR tab.
 438          *                                      For PSoC 3/5LP devices, the VDDD supply
 439          *                                      voltage is considered and for PSoC 4A-L,
 440          *                                      the VBUS supply voltage is considered.
 441          *
 442          * \globalvars
 443          *   \ref USBUART_device
 444          *   \ref USBUART_transferState
 445          *   \ref USBUART_configuration
 446          *   \ref USBUART_deviceStatus
 447          *
 448          *   \ref USBUART_deviceAddress - Contains the current device address. This
 449          *       variable is initialized to zero in this API. The Host starts to communicate
 450          *      to the device with address 0 and then sets it to a whatever value using a
 451          *      SET_ADDRESS request.
 452          *
 453          *   \ref USBUART_lastPacketSize - Initialized to 0;
 454          *
 455          * \reentrant
 456          *  No.
 457          *
 458          *******************************************************************************/
 459          void USBUART_InitComponent(uint8 device, uint8 mode) 
 460          {
 461   1          /* Initialize _hidProtocol variable to comply with
 462   1          *  HID 7.2.6 Set_Protocol Request:
 463   1          *  "When initialized, all devices default to report protocol."
 464   1          */
 465   1      #if defined(USBUART_ENABLE_HID_CLASS)
 466   1          uint8 i;
 467   1      
 468   1          for (i = 0u; i < USBUART_MAX_INTERFACES_NUMBER; i++)
 469   1          {
 470   2              USBUART_hidProtocol[i] = USBUART_PROTOCOL_REPORT;
 471   2          }
 472   1      #endif /* USBUART_ENABLE_HID_CLASS */
 473   1      
 474   1          /* Store device number to access descriptor. */
 475   1          USBUART_device = device;
 476   1      
 477   1          /* Reset component internal variables. */
 478   1          USBUART_transferState   = USBUART_TRANS_STATE_IDLE;
 479   1          USBUART_configurationChanged = 0u;
 480   1          USBUART_configuration   = 0u;
 481   1          USBUART_interfaceNumber = 0u;
 482   1          USBUART_deviceAddress   = 0u;
 483   1          USBUART_deviceStatus    = 0u;
 484   1          USBUART_lastPacketSize  = 0u;
 485   1      
 486   1          /* Enable component interrupts. */
 487   1      #if (CY_PSOC4)
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 9   

                  CyIntEnable(USBUART_INTR_HI_VECT_NUM);
                  CyIntEnable(USBUART_INTR_MED_VECT_NUM);
                  CyIntEnable(USBUART_INTR_LO_VECT_NUM);
              #else
 492   1          CyIntEnable(USBUART_BUS_RESET_VECT_NUM);
 493   1          CyIntEnable(USBUART_EP_0_VECT_NUM);
 494   1      
 495   1          #if (USBUART_SOF_ISR_ACTIVE)
 496   1              CyIntEnable(USBUART_SOF_VECT_NUM);
 497   1          #endif /* (USBUART_SOF_ISR_ACTIVE) */
 498   1      
 499   1          #if (USBUART_EP1_ISR_ACTIVE)
 500   1              CyIntEnable(USBUART_EP_1_VECT_NUM);
 501   1          #endif /* (USBUART_EP1_ISR_ACTIVE) */
 502   1      
 503   1          #if (USBUART_EP2_ISR_ACTIVE)
 504   1              CyIntEnable(USBUART_EP_2_VECT_NUM);
 505   1          #endif /* (USBUART_EP5_ISR_ACTIVE) */
 506   1      
 507   1          #if (USBUART_EP3_ISR_ACTIVE)
 508   1              CyIntEnable(USBUART_EP_3_VECT_NUM);
 509   1          #endif /* (USBUART_EP5_ISR_ACTIVE) */
 510   1      
 511   1          #if (USBUART_EP4_ISR_ACTIVE)
                      CyIntEnable(USBUART_EP_4_VECT_NUM);
                  #endif /* (USBUART_EP5_ISR_ACTIVE) */
 514   1      
 515   1          #if (USBUART_EP5_ISR_ACTIVE)
                      CyIntEnable(USBUART_EP_5_VECT_NUM);
                  #endif /* (USBUART_EP5_ISR_ACTIVE) */
 518   1      
 519   1          #if (USBUART_EP6_ISR_ACTIVE)
                      CyIntEnable(USBUART_EP_6_VECT_NUM);
                  #endif /* USBUART_EP6_ISR_REMOVE */
 522   1      
 523   1          #if (USBUART_EP7_ISR_ACTIVE)
                      CyIntEnable(USBUART_EP_7_VECT_NUM);
                  #endif /* (USBUART_EP7_ISR_ACTIVE) */
 526   1      
 527   1          #if (USBUART_EP8_ISR_ACTIVE)
                      CyIntEnable(USBUART_EP_8_VECT_NUM);
                  #endif /* (USBUART_EP8_ISR_ACTIVE) */
 530   1      #endif /* (CY_PSOC4) */
 531   1      
 532   1      #if (USBUART_EP_MANAGEMENT_DMA && USBUART_ARB_ISR_ACTIVE)
                  /* Enable ARB EP interrupt sources. */
                  USBUART_ARB_INT_EN_REG = USBUART_DEFAULT_ARB_INT_EN;
              
                  #if (CY_PSOC3 || CY_PSOC5)
                      CyIntEnable(USBUART_ARB_VECT_NUM);
                  #endif /* (CY_PSOC3 || CY_PSOC5) */
              #endif   /* (USBUART_EP_MANAGEMENT_DMA && USBUART_ARB_ISR_ACTIVE) */
 540   1      
 541   1      /* Arbiter configuration for DMA transfers. */
 542   1      #if (USBUART_EP_MANAGEMENT_DMA)
                  /* Configure Arbiter for Manual or Auto DMA operation and clear configuration completion. */
                  USBUART_ARB_CFG_REG = USBUART_DEFAULT_ARB_CFG;
              
                  #if (CY_PSOC4)
                      /* Enable DMA operation. */
                      CyDmaEnable();
              
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 10  

                      #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
                          /* Change DMA priority to be highest. */
                           CyIntSetPriority(CYDMA_INTR_NUMBER, USBUART_DMA_AUTO_INTR_PRIO);
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (CY_PSOC4) */
              
                  #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
                      #if (CY_PSOC4)
                          /* Enable DMA interrupt to handle DMA management. */
                          CyIntEnable(CYDMA_INTR_NUMBER);
                      #else
                          #if (USBUART_EP_DMA_AUTO_OPT == 0u)
                              /* Initialize interrupts which handle verification of successful DMA transaction. */
                              USBUART_EP_DMA_Done_isr_StartEx(&USBUART_EP_DMA_DONE_ISR);
                              USBUART_EP17_DMA_Done_SR_InterruptEnable();
                              USBUART_EP8_DMA_Done_SR_InterruptEnable();
                          #endif /* (USBUART_EP_DMA_AUTO_OPT == 0u) */
                      #endif /* (CY_PSOC4) */
                  #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
              #endif /* (USBUART_EP_MANAGEMENT_DMA) */
 570   1      
 571   1          /* Enable USB regulator depends on operation voltage. IMO Locking is enabled in Init(). */
 572   1          switch(mode)
 573   1          {
 574   2          case USBUART_3V_OPERATION:
 575   2              /* Disable regulator for 3V operation. */
 576   2              USBUART_CR1_REG &= (uint8) ~USBUART_CR1_REG_ENABLE;
 577   2              break;
 578   2      
 579   2          case USBUART_5V_OPERATION:
 580   2              /* Enable regulator for 5V operation. */
 581   2              USBUART_CR1_REG |= (uint8)  USBUART_CR1_REG_ENABLE;
 582   2              break;
 583   2      
 584   2          default: /* Check DWR settings of USB power supply. */
 585   2          #if (USBUART_VDDD_MV < USBUART_3500MV)
                      /* Disable regulator for 3V operation. */
                      USBUART_CR1_REG &= (uint8) ~USBUART_CR1_REG_ENABLE;
                  #else
 589   2              /* Enable regulator for 5V operation. */
 590   2              USBUART_CR1_REG |= (uint8)  USBUART_CR1_REG_ENABLE;
 591   2          #endif /* (USBUART_VDDD_MV < USBUART_3500MV) */
 592   2              break;
 593   2          }
 594   1      
 595   1      #if (CY_PSOC4)
                  /* Clear bus activity. */
                  USBUART_CR1_REG &= (uint32) ~USBUART_CR1_BUS_ACTIVITY;
              
                  /* Clear EP0 count register. */
                  USBUART_EP0_CNT_REG = USBUART_CLEAR_REG;
              
                  /* Set EP0.CR: ACK Setup, NAK IN/OUT. */
                  USBUART_EP0_CR_REG = USBUART_MODE_NAK_IN_OUT;
              
                  #if (USBUART_LPM_ACTIVE)
                      if (NULL != USBUART_GetBOSPtr())
                      {
                          /* Enable LPM and acknowledge LPM packets for active device.
                          * Reset NYET_EN and SUB_RESP bits in the LPM_CTRL register.
                          */
                          USBUART_LPM_CTRL_REG = (USBUART_LPM_CTRL_LPM_EN | \
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 11  

                                                           USBUART_LPM_CTRL_LPM_ACK_RESP);
                      }
                      else
                      {
                          /* Disable LPM for active device. */
                          USBUART_LPM_CTRL_REG &= (uint32) ~USBUART_LPM_CTRL_LPM_EN;
                      }
                  #endif /* (USBUART_LPM_ACTIVE) */
              
                  /* Enable device to responds to USB traffic with address 0. */
                  USBUART_CR0_REG = USBUART_DEFUALT_CR0;
              
              #else
 625   1          /* Set EP0.CR: ACK Setup, STALL IN/OUT. */
 626   1          USBUART_EP0_CR_REG = USBUART_MODE_STALL_IN_OUT;
 627   1      
 628   1          /* Enable device to respond to USB traffic with address 0. */
 629   1          USBUART_CR0_REG = USBUART_DEFUALT_CR0;
 630   1          CyDelayCycles(USBUART_WAIT_CR0_REG_STABILITY);
 631   1      #endif /* (CY_PSOC4) */
 632   1      
 633   1          /* Enable D+ pull-up and keep USB control on IO. */
 634   1          USBUART_USBIO_CR1_REG = USBUART_USBIO_CR1_USBPUEN;
 635   1      }
 636          
 637          
 638          /*******************************************************************************
 639          * Function Name: USBUART_ReInitComponent
 640          ****************************************************************************//**
 641          *
 642          *  This function reinitialize the component configuration and is
 643          *  intend to be called from the Reset interrupt.
 644          *
 645          * \globalvars
 646          *   USBUART_device - Contains the device number of the desired Device
 647          *        Descriptor. The device number can be found in the Device Descriptor tab
 648          *       of the Configure dialog, under the settings of the desired Device Descriptor,
 649          *       in the Device Number field.
 650          *   USBUART_transferState - This variable is used by the communication
 651          *       functions to handle the current transfer state. Initialized to
 652          *       TRANS_STATE_IDLE in this API.
 653          *   USBUART_configuration - Contains the current configuration number
 654          *       set by the Host using a SET_CONFIGURATION request.
 655          *       Initialized to zero in this API.
 656          *   USBUART_deviceAddress - Contains the current device address. This
 657          *       variable is initialized to zero in this API. The Host starts to communicate
 658          *      to the device with address 0 and then sets it to a whatever value using
 659          *      a SET_ADDRESS request.
 660          *   USBUART_deviceStatus - Initialized to 0.
 661          *       This is a two-bit variable which contains the power status in the first bit
 662          *       (DEVICE_STATUS_BUS_POWERED or DEVICE_STATUS_SELF_POWERED) and the remote
 663          *       wakeup status (DEVICE_STATUS_REMOTE_WAKEUP) in the second bit.
 664          *   USBUART_lastPacketSize - Initialized to 0;
 665          *
 666          * \reentrant
 667          *  No.
 668          *
 669          *******************************************************************************/
 670          void USBUART_ReInitComponent(void) 
 671          {
 672   1          /* Initialize _hidProtocol variable to comply with HID 7.2.6 Set_Protocol
 673   1          *  Request: "When initialized, all devices default to report protocol."
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 12  

 674   1          */
 675   1      #if defined(USBUART_ENABLE_HID_CLASS)
 676   1          uint8 i;
 677   1      
 678   1          for (i = 0u; i < USBUART_MAX_INTERFACES_NUMBER; i++)
 679   1          {
 680   2              USBUART_hidProtocol[i] = USBUART_PROTOCOL_REPORT;
 681   2          }
 682   1      #endif /* USBUART_ENABLE_HID_CLASS */
 683   1      
 684   1          /* Reset component internal variables. */
 685   1          USBUART_transferState   = USBUART_TRANS_STATE_IDLE;
 686   1          USBUART_configurationChanged = 0u;
 687   1          USBUART_configuration   = 0u;
 688   1          USBUART_interfaceNumber = 0u;
 689   1          USBUART_deviceAddress   = 0u;
 690   1          USBUART_deviceStatus    = 0u;
 691   1          USBUART_lastPacketSize  = 0u;
 692   1      
 693   1      #if (CY_PSOC4)
                  /* Set EP0.CR: ACK Setup, NAK IN/OUT. */
                  USBUART_EP0_CR_REG = USBUART_MODE_NAK_IN_OUT;
              #else
 697   1          /* Set EP0.CR: ACK Setup, STALL IN/OUT. */
 698   1          USBUART_EP0_CR_REG = USBUART_MODE_STALL_IN_OUT;
 699   1      #endif /* (CY_PSOC4) */
 700   1      
 701   1          /* Enable device to respond to USB traffic with address 0. */
 702   1          USBUART_CR0_REG = USBUART_DEFUALT_CR0;
 703   1      }
 704          
 705          
 706          /*******************************************************************************
 707          * Function Name: USBUART_Stop
 708          ****************************************************************************//**
 709          *
 710          *  This function shuts down the USB function including to release
 711          *  the D+ pull-up and disabling the SIE.
 712          *
 713          * \globalvars
 714          *   \ref USBUART_configuration
 715          *
 716          *   USBUART_deviceAddress - Contains the current device address. This
 717          *       variable is initialized to zero in this API. The Host starts to communicate
 718          *      to the device with address 0 and then sets it to a whatever value using
 719          *      a SET_ADDRESS request.
 720          *
 721          *   \ref USBUART_deviceStatus
 722          *
 723          *   \ref USBUART_configurationChanged
 724          *
 725          *   USBUART_intiVar -  This variable is set to zero
 726          *
 727          *******************************************************************************/
 728          void USBUART_Stop(void) 
 729          {
 730   1          uint8 enableInterrupts;
 731   1      
 732   1      #if (USBUART_EP_MANAGEMENT_DMA)
                  /* Stop all DMA channels. */
                  USBUART_Stop_DMA(USBUART_MAX_EP);
              #endif /* (USBUART_EP_MANAGEMENT_DMA) */
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 13  

 736   1      
 737   1          enableInterrupts = CyEnterCriticalSection();
 738   1      
 739   1          /* Disable USB IP to respond to USB traffic. */
 740   1          USBUART_CR0_REG &= (uint8) ~USBUART_CR0_ENABLE;
 741   1      
 742   1          /* Disable D+ pull-up. */
 743   1          USBUART_USBIO_CR1_REG &= (uint8) ~ USBUART_USBIO_CR1_USBPUEN;
 744   1      
 745   1      #if (CY_PSOC4)
                  /* Disable USBFS block. */
                  USBUART_POWER_CTRL_REG &= (uint32) ~USBUART_POWER_CTRL_ENABLE;
              #else
 749   1          /* Clear power active and standby mode templates. */
 750   1          USBUART_PM_ACT_CFG_REG  &= (uint8) ~USBUART_PM_ACT_EN_FSUSB;
 751   1          USBUART_PM_STBY_CFG_REG &= (uint8) ~USBUART_PM_STBY_EN_FSUSB;
 752   1      #endif /* (CY_PSOC4) */
 753   1      
 754   1          CyExitCriticalSection(enableInterrupts);
 755   1      
 756   1          /* Disable component interrupts. */
 757   1      #if (CY_PSOC4)
                  CyIntDisable(USBUART_INTR_HI_VECT_NUM);
                  CyIntDisable(USBUART_INTR_LO_VECT_NUM);
                  CyIntDisable(USBUART_INTR_MED_VECT_NUM);
              #else
 762   1      
 763   1          CyIntDisable(USBUART_BUS_RESET_VECT_NUM);
 764   1          CyIntDisable(USBUART_EP_0_VECT_NUM);
 765   1      
 766   1          #if (USBUART_SOF_ISR_ACTIVE)
 767   1              CyIntDisable(USBUART_SOF_VECT_NUM);
 768   1          #endif /* (USBUART_SOF_ISR_ACTIVE) */
 769   1      
 770   1          #if (USBUART_EP1_ISR_ACTIVE)
 771   1              CyIntDisable(USBUART_EP_1_VECT_NUM);
 772   1          #endif /* (USBUART_EP1_ISR_ACTIVE) */
 773   1      
 774   1          #if (USBUART_EP2_ISR_ACTIVE)
 775   1              CyIntDisable(USBUART_EP_2_VECT_NUM);
 776   1          #endif /* (USBUART_EP2_ISR_ACTIVE) */
 777   1      
 778   1          #if (USBUART_EP3_ISR_ACTIVE)
 779   1              CyIntDisable(USBUART_EP_3_VECT_NUM);
 780   1          #endif /* (USBUART_EP3_ISR_ACTIVE) */
 781   1      
 782   1          #if (USBUART_EP4_ISR_ACTIVE)
                      CyIntDisable(USBUART_EP_4_VECT_NUM);
                  #endif /* (USBUART_EP4_ISR_ACTIVE) */
 785   1      
 786   1          #if (USBUART_EP5_ISR_ACTIVE)
                      CyIntDisable(USBUART_EP_5_VECT_NUM);
                  #endif /* (USBUART_EP5_ISR_ACTIVE) */
 789   1      
 790   1          #if (USBUART_EP6_ISR_ACTIVE)
                      CyIntDisable(USBUART_EP_6_VECT_NUM);
                  #endif /* USBUART_EP6_ISR_REMOVE */
 793   1      
 794   1          #if (USBUART_EP7_ISR_ACTIVE)
                      CyIntDisable(USBUART_EP_7_VECT_NUM);
                  #endif /* (USBUART_EP7_ISR_ACTIVE) */
 797   1      
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 14  

 798   1          #if (USBUART_EP8_ISR_ACTIVE)
                      CyIntDisable(USBUART_EP_8_VECT_NUM);
                  #endif /* (USBUART_EP8_ISR_ACTIVE) */
 801   1      #endif /* (CY_PSOC4) */
 802   1      
 803   1          /* Reset component internal variables. */
 804   1          USBUART_configurationChanged = 0u;
 805   1          USBUART_configuration   = 0u;
 806   1          USBUART_interfaceNumber = 0u;
 807   1          USBUART_deviceAddress   = 0u;
 808   1          USBUART_deviceStatus    = 0u;
 809   1      
 810   1          /* It is mandatory for correct device startup. */
 811   1          USBUART_initVar = 0u;
 812   1      }
 813          
 814          
 815          /*******************************************************************************
 816          * Function Name: USBUART_CheckActivity
 817          ****************************************************************************//**
 818          *
 819          *  This function returns the activity status of the bus. It clears the hardware
 820          *  status to provide updated status on the next call of this function. It
 821          *  provides a way to determine whether any USB bus activity occurred. The
 822          *  application should use this function to determine if the USB suspend
 823          *  conditions are met.
 824          *
 825          *
 826          * \return
 827          *  cystatus: Status of the bus since the last call of the function.
 828          *  Return Value |   Description
 829          *  -------------|---------------------------------------------------------------
 830          *  1            |Bus activity was detected since the last call to this function
 831          *  0            |Bus activity was not detected since the last call to this function
 832          *
 833          *
 834          *******************************************************************************/
 835          uint8 USBUART_CheckActivity(void) 
 836          {
 837   1          uint8 cr1Reg = USBUART_CR1_REG;
 838   1      
 839   1          /* Clear bus activity. */
 840   1          USBUART_CR1_REG = (cr1Reg & (uint8) ~USBUART_CR1_BUS_ACTIVITY);
 841   1      
 842   1          /* Get bus activity. */
 843   1          return ((0u != (cr1Reg & USBUART_CR1_BUS_ACTIVITY)) ? (1u) : (0u));
 844   1      }
 845          
 846          
 847          /*******************************************************************************
 848          * Function Name: USBUART_GetConfiguration
 849          ****************************************************************************//**
 850          *
 851          *  This function gets the current configuration of the USB device.
 852          *
 853          * \return
 854          *  Returns the currently assigned configuration. Returns 0 if the device
 855          *  is not configured
 856          *
 857          *******************************************************************************/
 858          uint8 USBUART_GetConfiguration(void) 
 859          {
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 15  

 860   1          return (USBUART_configuration);
 861   1      }
 862          
 863          
 864          /*******************************************************************************
 865          * Function Name: USBUART_IsConfigurationChanged
 866          ****************************************************************************//**
 867          *
 868          *  This function returns the clear-on-read configuration state.  It is useful
 869          *  when the host sends double SET_CONFIGURATION request with the same 
 870          *  configuration number or changes alternate settings of the interface. 
 871          *  After configuration has been changed the OUT endpoints must be enabled and IN 
 872          *  endpoint must be loaded with data to start communication with the host.
 873          *
 874          * \return
 875          *  None-zero value when new configuration has been changed, otherwise zero is
 876          *  returned.
 877          *
 878          * \globalvars
 879          *
 880          *  \ref USBUART_configurationChanged - This variable is set to 1 after
 881          *   a SET_CONFIGURATION request and cleared in this function.
 882          *
 883          *******************************************************************************/
 884          uint8 USBUART_IsConfigurationChanged(void) 
 885          {
 886   1          uint8 res = 0u;
 887   1      
 888   1          if (USBUART_configurationChanged != 0u)
 889   1          {
 890   2              res = USBUART_configurationChanged;
 891   2              USBUART_configurationChanged = 0u;
 892   2          }
 893   1      
 894   1          return (res);
 895   1      }
 896          
 897          
 898          /*******************************************************************************
 899          * Function Name: USBUART_GetInterfaceSetting
 900          ****************************************************************************//**
 901          *
 902          *  This function gets the current alternate setting for the specified interface.
 903          *  It is useful to identify which alternate settings are active in the specified 
 904          *  interface.
 905          *
 906          *  \param
 907          *  interfaceNumber interface number
 908          *
 909          * \return
 910          *  Returns the current alternate setting for the specified interface.
 911          *
 912          *******************************************************************************/
 913          uint8  USBUART_GetInterfaceSetting(uint8 interfaceNumber)
 914                                                              
 915          {
 916   1          return (USBUART_interfaceSetting[interfaceNumber]);
 917   1      }
 918          
 919          
 920          /*******************************************************************************
 921          * Function Name: USBUART_GetEPState
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 16  

 922          ****************************************************************************//**
 923          *
 924          *  This function returns the state of the requested endpoint.
 925          *
 926          * \param epNumber Data endpoint number
 927          *
 928          * \return
 929          *  Returns the current state of the specified USBFS endpoint. Symbolic names and
 930          *  their associated values are given in the following table. Use these constants
 931          *  whenever you write code to change the state of the endpoints, such as ISR
 932          *  code, to handle data sent or received.
 933          *
 934          *  Return Value           | Description
 935          *  -----------------------|-----------------------------------------------------
 936          *  USBFS_NO_EVENT_PENDING |The endpoint is awaiting SIE action
 937          *  USBFS_EVENT_PENDING    |The endpoint is awaiting CPU action
 938          *  USBFS_NO_EVENT_ALLOWED |The endpoint is locked from access
 939          *  USBFS_IN_BUFFER_FULL   |The IN endpoint is loaded and the mode is set to ACK IN
 940          *  USBFS_IN_BUFFER_EMPTY  |An IN transaction occurred and more data can be loaded
 941          *  USBFS_OUT_BUFFER_EMPTY |The OUT endpoint is set to ACK OUT and is waiting for data
 942          *  USBFS_OUT_BUFFER_FULL  |An OUT transaction has occurred and data can be read
 943          *
 944          *******************************************************************************/
 945          uint8 USBUART_GetEPState(uint8 epNumber) 
 946          {
 947   1          return (USBUART_EP[epNumber].apiEpState);
 948   1      }
 949          
 950          
 951          /*******************************************************************************
 952          * Function Name: USBUART_GetEPCount
 953          ****************************************************************************//**
 954          *
 955          *  This function supports Data Endpoints only(EP1-EP8).
 956          *  Returns the transfer count for the requested endpoint.  The value from
 957          *  the count registers includes 2 counts for the two byte checksum of the
 958          *  packet.  This function subtracts the two counts.
 959          *
 960          *  \param epNumber Data Endpoint Number.
 961          *                   Valid values are between 1 and 8.
 962          *
 963          * \return
 964          *  Returns the current byte count from the specified endpoint or 0 for an
 965          *  invalid endpoint.
 966          *
 967          *******************************************************************************/
 968          uint16 USBUART_GetEPCount(uint8 epNumber) 
 969          {
 970   1          uint16 cntr = 0u;
 971   1      
 972   1          if ((epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
 973   1          {
 974   2              /* Get 11-bits EP counter where epCnt0 - 3 bits MSB and epCnt1 - 8 bits LSB. */
 975   2              cntr  = ((uint16) USBUART_SIE_EP_BASE.sieEp[epNumber].epCnt0) & USBUART_EPX_CNT0_MASK;
 976   2              cntr  = ((uint16) (cntr << 8u)) | ((uint16) USBUART_SIE_EP_BASE.sieEp[epNumber].epCnt1);
 977   2              cntr -= USBUART_EPX_CNTX_CRC_COUNT;
 978   2          }
 979   1      
 980   1          return (cntr);
 981   1      }
 982          
 983          
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 17  

 984          #if (USBUART_EP_MANAGEMENT_DMA)
              #if (CY_PSOC4)
                  /*******************************************************************************
                  * Function Name: USBUART_InitEpDma
                  ****************************************************************************//**
                  *
                  *  This function configures priority for all DMA channels utilized by the
                  *  component. Also sets callbacks for DMA auto mode.
                  *
                  *******************************************************************************/
                  static void USBUART_InitEpDma(void)
                  {
                  #if (USBUART_DMA1_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep1_dma_CHANNEL] = USBUART_ep1_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA1_ACTIVE) */
              
                  #if (USBUART_DMA2_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep2_dma_CHANNEL] = USBUART_ep2_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA2_ACTIVE) */
              
                  #if (USBUART_DMA3_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep3_dma_CHANNEL] = USBUART_ep3_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA3_ACTIVE) */
              
                  #if (USBUART_DMA4_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep4_dma_CHANNEL] = USBUART_ep4_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA4_ACTIVE) */
              
                  #if (USBUART_DMA5_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep5_dma_CHANNEL] = USBUART_ep5_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA5_ACTIVE) */
              
                  #if (USBUART_DMA6_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep6_dma_CHANNEL] = USBUART_ep6_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA6_ACTIVE) */
              
                  #if (USBUART_DMA7_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep7_dma_CHANNEL] = USBUART_ep7_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA7_ACTIVE) */
              
                  #if (USBUART_DMA8_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBUART_ep8_dma_CHANNEL] = USBUART_ep8_dma_CHANNEL_CFG;
                  #endif /* (USBUART_DMA8_ACTIVE) */
              
                  #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
                      /* Initialize DMA channel callbacks. */
                      #if (USBUART_DMA1_ACTIVE)
                          (void) USBUART_ep1_dma_SetInterruptCallback(&USBUART_EP1_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA1_ACTIVE) */
              
                      #if (USBUART_DMA2_ACTIVE)
                          (void) USBUART_ep2_dma_SetInterruptCallback(&USBUART_EP2_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA2_ACTIVE) */
              
                      #if (USBUART_DMA3_ACTIVE)
                          (void) USBUART_ep3_dma_SetInterruptCallback(&USBUART_EP3_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA3_ACTIVE) */
              
                      #if (USBUART_DMA4_ACTIVE)
                          (void) USBUART_ep4_dma_SetInterruptCallback(&USBUART_EP4_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA4_ACTIVE) */
              
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 18  

                      #if (USBUART_DMA5_ACTIVE)
                          (void) USBUART_ep5_dma_SetInterruptCallback(&USBUART_EP5_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA5_ACTIVE) */
              
                      #if (USBUART_DMA6_ACTIVE)
                          (void) USBUART_ep6_dma_SetInterruptCallback(&USBUART_EP6_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA6_ACTIVE) */
              
                      #if (USBUART_DMA7_ACTIVE)
                          (void) USBUART_ep7_dma_SetInterruptCallback(&USBUART_EP7_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA7_ACTIVE) */
              
                      #if (USBUART_DMA8_ACTIVE)
                          (void) USBUART_ep8_dma_SetInterruptCallback(&USBUART_EP8_DMA_DONE_ISR);
                      #endif /* (USBUART_DMA8_ACTIVE) */
                  #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                  }
              #else
              
              
                  /***************************************************************************
                  * Function Name: USBUART_InitEP_DMA
                  ************************************************************************//**
                  *
                  *  This function allocates and initializes a DMA channel to be used by the
                  *  USBUART_LoadInEP() or USBUART_ReadOutEP() APIs for data
                  *  transfer. It is available when the Endpoint Memory Management parameter
                  *  is set to DMA.
                  *
                  *  This function is automatically called from the USBFS_LoadInEP() and USBFS_ReadOutEP() APIs.
                  *
                  *  \param epNumber Contains the data endpoint number.
                  *            Valid values are between 1 and 8.
                  *  \param *pData Pointer to a data array that is related to the EP transfers.
                  *
                  * \reentrant No.
                  *
                  ***************************************************************************/
                  void USBUART_InitEP_DMA(uint8 epNumber, const uint8 *pData)
                                                                                  
                  {
                      uint16 src;
                      uint16 dst;
              
                  #if (CY_PSOC3)
                      src = HI16(CYDEV_SRAM_BASE);
                      dst = HI16(CYDEV_PERIPH_BASE);
                      pData = pData;
                  #else
                      if ((USBUART_EP[epNumber].addr & USBUART_DIR_IN) != 0u)
                      {
                          /* IN endpoint: source is memory buffer. */
                          src = HI16(pData);
                          dst = HI16(CYDEV_PERIPH_BASE);
                      }
                      else
                      {
                          /* OUT endpoint: source is USB IP memory buffer. */
                          src = HI16(CYDEV_PERIPH_BASE);
                          dst = HI16(pData);
                      }
                  #endif  /* (CY_PSOC3) */
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 19  

              
                      switch(epNumber)
                      {
                  #if (USBUART_DMA1_ACTIVE)
                      case USBUART_EP1:
                          USBUART_DmaChan[epNumber] = USBUART_ep1_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                  USBUART_DMA_REQUEST_PE
             -R_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA1_ACTIVE) */
              
                  #if (USBUART_DMA2_ACTIVE)
                      case USBUART_EP2:
                          USBUART_DmaChan[epNumber] = USBUART_ep2_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                  USBUART_DMA_REQUEST_PE
             -R_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA2_ACTIVE) */
              
                  #if (USBUART_DMA3_ACTIVE)
                          case USBUART_EP3:
                              USBUART_DmaChan[epNumber] = USBUART_ep3_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                      USBUART_DMA_REQUES
             -T_PER_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA3_ACTIVE) */
              
                  #if (USBUART_DMA4_ACTIVE)
                          case USBUART_EP4:
                              USBUART_DmaChan[epNumber] = USBUART_ep4_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                      USBUART_DMA_REQUES
             -T_PER_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA4_ACTIVE) */
              
                  #if (USBUART_DMA5_ACTIVE)
                          case USBUART_EP5:
                              USBUART_DmaChan[epNumber] = USBUART_ep5_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                      USBUART_DMA_REQUES
             -T_PER_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA5_ACTIVE) */
              
                  #if (USBUART_DMA6_ACTIVE)
                      case USBUART_EP6:
                          USBUART_DmaChan[epNumber] = USBUART_ep6_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                  USBUART_DMA_REQUEST_PE
             -R_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA6_ACTIVE) */
              
                  #if (USBUART_DMA7_ACTIVE)
                      case USBUART_EP7:
                              USBUART_DmaChan[epNumber] = USBUART_ep7_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
                                                                                                      USBUART_DMA_REQUES
             -T_PER_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA7_ACTIVE) */
              
                  #if (USBUART_DMA8_ACTIVE)
                      case USBUART_EP8:
                              USBUART_DmaChan[epNumber] = USBUART_ep8_DmaInitialize(USBUART_DMA_BYTES_PER_BURST,
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 20  

                                                                                                      USBUART_DMA_REQUES
             -T_PER_BURST, src, dst);
                          break;
                  #endif /* (USBUART_DMA8_ACTIVE) */
              
                      default:
                          /* Do nothing for endpoints other than 1-8. */
                          break;
                      }
              
                      if ((epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
                      {
                          USBUART_DmaTd[epNumber] = CyDmaTdAllocate();
              
                      #if (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u))
                          USBUART_DmaNextTd[epNumber] = CyDmaTdAllocate();
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u)) */
                      }
                  }
              #endif /* (CY_PSOC4) */
              
                  /***************************************************************************
                  * Function Name: USBUART_Stop_DMA
                  ************************************************************************//**
                  *  
                  *  This function stops DMA channel associated with endpoint. It is available 
                  *  when the Endpoint Buffer Management parameter is set to DMA. Call this 
                  *  function when endpoint direction is changed from IN to OUT or vice versa 
                  *  to trigger DMA re-configuration when USBUART_LoadInEP() or 
                  *  USBUART_ReadOutEP() functions are called the first time. 
                  *  
                  *  \param epNumber: The data endpoint number for which associated DMA 
                  *  channel is stopped. The range of valid values is between 1 and 8. To stop 
                  *  all DMAs associated with endpoints call this function with 
                  *  USBUART_MAX_EP argument.
                  *
                  * \reentrant
                  *  No.
                  *
                  ***************************************************************************/
                  void USBUART_Stop_DMA(uint8 epNumber) 
                  {
                      uint8 i;
              
                      i = (epNumber < USBUART_MAX_EP) ? epNumber : USBUART_EP1;
              
                      do
                      {
                      #if (CY_PSOC4)
                          if (0u != USBUART_DmaChan[i])
                          {
                              USBUART_CyDmaChDisable(USBUART_DmaChan[i]);
                          }
                      #else
                          if(USBUART_DmaTd[i] != DMA_INVALID_TD)
                          {
                              (void) CyDmaChDisable(USBUART_DmaChan[i]);
                              CyDmaTdFree(USBUART_DmaTd[i]);
                              USBUART_DmaTd[i] = DMA_INVALID_TD;
                          }
              
                          #if (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u))
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 21  

                              if(USBUART_DmaNextTd[i] != DMA_INVALID_TD)
                              {
                                  CyDmaTdFree(USBUART_DmaNextTd[i]);
                                  USBUART_DmaNextTd[i] = DMA_INVALID_TD;
                              }
                          #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u)) */
              
                      #endif /* (CY_PSOC4) */
                          i++;
                      }
                      while ((i < USBUART_MAX_EP) && (epNumber == USBUART_MAX_EP));
                  }
              #endif /* (USBUART_EP_MANAGEMENT_DMA) */
1237          
1238          
1239          #if (CY_PSOC3 || CY_PSOC5)
1240          #if (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u))
                  /***************************************************************************
                  * Function Name: USBUART_LoadNextInEP
                  ************************************************************************//**
                  *
                  * Summary:
                  *  This internal function is used for IN endpoint DMA reconfiguration in
                  *  Auto DMA mode.
                  *
                  * Parameters:
                  *  epNumber: Contains the data endpoint number.
                  *  mode:   0 - Configure DMA to send the the rest of data.
                  *          1 - Configure DMA to repeat 2 last bytes of the first burst.
                  *
                  ***************************************************************************/
                  void USBUART_LoadNextInEP(uint8 epNumber, uint8 mode) 
                  {
                      reg16 *convert;
              
                      if (mode == 0u)
                      {
                          /* Configure DMA to send rest of data. */
                          /* CyDmaTdSetConfiguration API is optimized to change transfer length only and configure TD. *
             -/
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBUART_DmaTd[epNumber]].TD0[0u];
                          /* Set transfer length. */
                          CY_SET_REG16(convert, USBUART_inLength[epNumber] - USBUART_DMA_BYTES_PER_BURST);
                          /* CyDmaTdSetAddress API is optimized to change source address only. */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBUART_DmaTd[epNumber]].TD1[0u];
                          CY_SET_REG16(convert, LO16((uint32)USBUART_inDataPointer[epNumber] +
                                                          USBUART_DMA_BYTES_PER_BURST));
                          USBUART_inBufFull[epNumber] = 1u;
                      }
                      else
                      {
                          /* Configure DMA to repeat 2 last bytes of the first burst. */
                          /* CyDmaTdSetConfiguration API is optimized to change transfer length only and configure TD. *
             -/
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBUART_DmaTd[epNumber]].TD0[0u];
                          /* Set transfer length. */
                          CY_SET_REG16(convert, USBUART_DMA_BYTES_REPEAT);
                          /* CyDmaTdSetAddress API is optimized to change source address only. */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBUART_DmaTd[epNumber]].TD1[0u];
                          CY_SET_REG16(convert,  LO16((uint32)USBUART_inDataPointer[epNumber] +
                                                 (USBUART_DMA_BYTES_PER_BURST - USBUART_DMA_BYTES_REPEAT)));
                      }
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 22  

              
                      /* CyDmaChSetInitialTd API is optimized to initialize TD. */
                      CY_DMA_CH_STRUCT_PTR[USBUART_DmaChan[epNumber]].basic_status[1u] = USBUART_DmaTd[epNumber];
                  }
              #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u)) */
1289          #endif /* (CY_PSOC3 || CY_PSOC5) */
1290          
1291          
1292          /*******************************************************************************
1293          * Function Name: USBUART_LoadInEP
1294          ****************************************************************************//**
1295          *
1296          *  This function performs different functionality depending on the Component’s
1297          *  configured Endpoint Buffer Management. This parameter is defined in
1298          *  the Descriptor Root in Component Configure window.
1299          *
1300          *  *Manual (Static/Dynamic Allocation):*
1301          *  This function loads and enables the specified USB data endpoint for an IN
1302          *  data transfer.
1303          *
1304          *  *DMA with Manual Buffer Management:*
1305          *  Configures DMA for a data transfer from system RAM to endpoint buffer.
1306          *  Generates request for a transfer.
1307          *
1308          *  *DMA with Automatic Buffer Management:*
1309          *  Configures DMA. This is required only once, so it is done only when parameter
1310          *  pData is not NULL. When the pData pointer is NULL, the function skips this
1311          *  task. Sets Data ready status: This generates the first DMA transfer and
1312          *  prepares data in endpoint buffer.
1313          *
1314          *  \param epNumber Contains the data endpoint number.
1315          *            Valid values are between 1 and 8.
1316          *  \param *pData A pointer to a data array from which the data for the endpoint space
1317          *          is loaded.
1318          *  \param length The number of bytes to transfer from the array and then send as
1319          *          a result of an IN request. Valid values are between 0 and 512
1320          *          (1023 for DMA with Automatic Buffer Management mode). The value 512
1321          *          is applicable if only one endpoint is used.
1322          *
1323          *
1324          * \reentrant
1325          *  No.
1326          *
1327          *******************************************************************************/
1328          void USBUART_LoadInEP(uint8 epNumber, const uint8 pData[], uint16 length)
1329                                                                                  
1330          {
1331   1          if ((epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
1332   1          {
1333   2          #if (!USBUART_EP_MANAGEMENT_DMA_AUTO)
1334   2              /* Limit length to available buffer USB IP buffer size.*/
1335   2              if (length > (USBUART_EPX_DATA_BUF_MAX - USBUART_EP[epNumber].buffOffset))
1336   2              {
1337   3                  length = USBUART_EPX_DATA_BUF_MAX - USBUART_EP[epNumber].buffOffset;
1338   3              }
1339   2          #endif /* (!USBUART_EP_MANAGEMENT_DMA_AUTO) */
1340   2      
1341   2              /* Set count and data toggle. */
1342   2              USBUART_SIE_EP_BASE.sieEp[epNumber].epCnt0 = (uint8) HI8(length) | USBUART_EP[epNumber].epToggle;
1343   2              USBUART_SIE_EP_BASE.sieEp[epNumber].epCnt1 = (uint8) LO8(length);
1344   2      
1345   2          #if (USBUART_EP_MANAGEMENT_MANUAL)
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 23  

1346   2              if (NULL != pData)
1347   2              {
1348   3                              /* Copy data using arbiter data register. */
1349   3                  uint16 i;
1350   3                  for (i = 0u; i < length; ++i)
1351   3                  {
1352   4                      USBUART_ARB_EP_BASE.arbEp[epNumber].rwDr = pData[i];
1353   4                  }
1354   3              }
1355   2      
1356   2              /* IN endpoint buffer is full - read to be read. */
1357   2              USBUART_EP[epNumber].apiEpState = USBUART_NO_EVENT_PENDING;
1358   2      
1359   2              /* Arm IN endpoint. */
1360   2              USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_EP[epNumber].epMode;
1361   2      
1362   2          #else
              
                      #if (CY_PSOC3 || CY_PSOC5LP)
                          /* Initialize DMA if it was not initialized. */
                          if (DMA_INVALID_TD == USBUART_DmaTd[epNumber])
                          {
                              USBUART_InitEP_DMA(epNumber, pData);
                          }
                      #endif /* (CY_PSOC3 || CY_PSOC5LP) */
              
                      #if (USBUART_EP_MANAGEMENT_DMA_MANUAL)
                          /* IN endpoint buffer will be fully loaded by DMA shortly. */
                          USBUART_EP[epNumber].apiEpState = USBUART_NO_EVENT_PENDING;
              
                          if ((pData != NULL) && (length > 0u))
                          {
                          #if (CY_PSOC4)
                              uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                              /* Disable DMA channel: start configuration. */
                              USBUART_CyDmaChDisable(channelNum);
              
                              /* Configure source and destination. */
                              USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) pData);
                              USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP_BASE.ar
             -bEp[epNumber].rwDr);
              
                              /* Configure DMA descriptor. */
                              --length;
                              USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG | len
             -gth |
                                                                      CYDMA_BYTE | CYDMA_ELEMENT_WORD | CYDMA_INC_SRC_AD
             -DR | CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
                              /* Validate descriptor to execute on following DMA request. */
                              USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
              
                              /* Enable DMA channel: configuration complete. */
                              USBUART_CyDmaChEnable(channelNum);
                          #else
                              /* Configure DMA to transfer data. */
                              (void) CyDmaChDisable(USBUART_DmaChan[epNumber]);
                              (void) CyDmaTdSetConfiguration(USBUART_DmaTd[epNumber], length, CY_DMA_DISABLE_TD, TD_TERM
             -IN_EN | TD_INC_SRC_ADR);
                              (void) CyDmaTdSetAddress(USBUART_DmaTd[epNumber], LO16((uint32) pData), LO16((uint32) &USB
             -UART_ARB_EP_BASE.arbEp[epNumber].rwDr));
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 24  

              
                              /* Enable DMA channel. */
                              (void) CyDmaChSetInitialTd(USBUART_DmaChan[epNumber], USBUART_DmaTd[epNumber]);
                              (void) CyDmaChEnable(USBUART_DmaChan[epNumber], 1u);
                          #endif /* (CY_PSOC4) */
              
                              /* Generate DMA request. */
                              USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint8)  USBUART_ARB_EPX_CFG_DMA_REQ;
                              USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint8) ~USBUART_ARB_EPX_CFG_DMA_REQ;
              
                              /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer has 
             -been completed. */
                          }
                          else
                          {
                              /* When zero-length packet: arm IN endpoint directly. */
                              USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_EP[epNumber].epMode;
                          }
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
                          if (pData != NULL)
                          {
                          #if (CY_PSOC4)
                              uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                              /* Store address of buffer. */
                              USBUART_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
              
                              /* Disable DMA channel: start configuration. */
                              USBUART_CyDmaChDisable(channelNum);
              
                              /* Set destination address. */
                              USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP_BASE.ar
             -bEp[epNumber].rwDr);
                              USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR1, (void*) &USBUART_ARB_EP_BASE.ar
             -bEp[epNumber].rwDr);
              
                              /* Configure DMA descriptor. */
                              USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG  |
                                                                      CYDMA_BYTE | CYDMA_ELEMENT_WORD | CYDMA_INC_SRC_AD
             -DR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                              /* Configure DMA descriptor. */
                              USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR1, USBUART_DMA_COMMON_CFG  |
                                                                      CYDMA_BYTE | CYDMA_ELEMENT_WORD | CYDMA_INC_SRC_AD
             -DR | CYDMA_CHAIN);
              
                              /* Enable interrupt from DMA channel. */
                              USBUART_CyDmaSetInterruptMask(channelNum);
              
                              /* Validate descriptor 1. It will not be invalided during operation. */
                              USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR1);
              
                              /* Enable DMA channel: configuration complete. */
                              USBUART_CyDmaChEnable(channelNum);
              
                          #else
                              (void) CyDmaChDisable(USBUART_DmaChan[epNumber]);
              
                              #if (USBUART_EP_DMA_AUTO_OPT == 0u)
                                  USBUART_inLength[epNumber] = length;
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 25  

                                  USBUART_inDataPointer[epNumber] = pData;
              
                                  /* Configure DMA to send data only for first burst */
                                  (void) CyDmaTdSetConfiguration(USBUART_DmaTd[epNumber],
                                      (length > USBUART_DMA_BYTES_PER_BURST) ? USBUART_DMA_BYTES_PER_BURST : length,
                                      USBUART_DmaNextTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR);
                                  (void) CyDmaTdSetAddress(USBUART_DmaTd[epNumber], LO16((uint32) pData),
                                                                                             LO16((uint32) &USBUART_ARB_
             -EP_BASE.arbEp[epNumber].rwDr));
              
                                  /* The second TD will be executed only when the first one fails.
                                  *  The intention of this TD is to generate NRQ interrupt
                                  *  and repeat 2 last bytes of the first burst.
                                  */
                                  (void) CyDmaTdSetConfiguration(USBUART_DmaNextTd[epNumber], 1u,
                                                                 USBUART_DmaNextTd[epNumber],
                                                                 USBUART_epX_TD_TERMOUT_EN[epNumber]);
              
                                  /* Configure DmaNextTd to clear Data Ready status. */
                                  (void) CyDmaTdSetAddress(USBUART_DmaNextTd[epNumber], LO16((uint32) &clearInDataRdySta
             -tus),
                                                                                                 LO16((uint32) &USBUART_
             -ARB_EP_BASE.arbEp[epNumber].epCfg));
                              #else
                                  /* Configure DMA to send all data. */
                                  (void) CyDmaTdSetConfiguration(USBUART_DmaTd[epNumber], length,
                                                                 USBUART_DmaTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR)
             -;
                                  (void) CyDmaTdSetAddress(USBUART_DmaTd[epNumber], LO16((uint32) pData),
                                                                                             LO16((uint32) &USBUART_ARB_
             -EP_BASE.arbEp[epNumber].rwDr));
                              #endif /* (USBUART_EP_DMA_AUTO_OPT == 0u) */
              
                              /* Clear any potential pending DMA requests before starting DMA channel to transfer data. 
             -*/
                              (void) CyDmaClearPendingDrq(USBUART_DmaChan[epNumber]);
                              /* Enable DMA. */
                              (void) CyDmaChSetInitialTd(USBUART_DmaChan[epNumber], USBUART_DmaTd[epNumber]);
                              (void) CyDmaChEnable(USBUART_DmaChan[epNumber], 1u);
                          #endif /* (CY_PSOC4) */
                          }
                          else
                          {
                              /* IN endpoint buffer (32 bytes) will shortly be preloaded by DMA. */
                              USBUART_EP[epNumber].apiEpState = USBUART_NO_EVENT_PENDING;
              
                              if (length > 0u)
                              {
                              #if (CY_PSOC4)
                                  uint32 lengthDescr0, lengthDescr1;
                                  uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                                  /* Get number of full bursts. */
                                  USBUART_DmaEpBurstCnt[epNumber] = (uint8) (length / USBUART_DMA_BYTES_PER_BURST);
              
                                  /* Get number of elements in the last burst. */
                                  USBUART_DmaEpLastBurstEl[epNumber] = (uint8) (length % USBUART_DMA_BYTES_PER_BURST);
              
                                  /* Get total number of bursts. */
                                  USBUART_DmaEpBurstCnt[epNumber] += (0u != USBUART_DmaEpLastBurstEl[epNumber]) ? 1u : 0
             -u;
              
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 26  

                                  /* Adjust number of data elements transferred in last burst. */
                                  USBUART_DmaEpLastBurstEl[epNumber] = (0u != USBUART_DmaEpLastBurstEl[epNumber]) ?
                                                                                        (USBUART_DmaEpLastBurstEl[epNumb
             -er] - 1u) :
                                                                                        (USBUART_DMA_BYTES_PER_BURST - 1
             -u);
              
                                  /* Get number of data elements to transfer for descriptor 0 and 1. */
                                  lengthDescr0 = (1u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNu
             -mber] : (USBUART_DMA_BYTES_PER_BURST - 1u);
                                  lengthDescr1 = (2u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNu
             -mber] : (USBUART_DMA_BYTES_PER_BURST - 1u);
              
              
                                  /* Mark which descriptor is last one to execute. */
                                  USBUART_DmaEpLastBurstEl[epNumber] |= (0u != (USBUART_DmaEpBurstCnt[epNumber] & 0x1u))
             - ?
                                                                                          USBUART_DMA_DESCR0_MASK : USBU
             -ART_DMA_DESCR1_MASK;
              
                                  /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger a
             -fter valid descriptor were executed. */
                                  USBUART_DmaEpBurstCnt[epNumber] = USBUART_DMA_GET_BURST_CNT(USBUART_DmaEpBurstCnt[epNu
             -mber]);
              
                                  /* Restore DMA settings for current transfer. */
                                  USBUART_CyDmaChDisable(channelNum);
              
                                  /* Restore destination address for input endpoint. */
                                  USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) ((uint32) USBUART_D
             -maEpBufferAddrBackup[epNumber]));
                                  USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR1, (void*) ((uint32) USBUART_D
             -maEpBufferAddrBackup[epNumber] +
                                                                                                                        
             -         USBUART_DMA_BYTES_PER_BURST));
              
                                  /* Set number of elements to transfer. */
                                  USBUART_CyDmaSetNumDataElements(channelNum, USBUART_DMA_DESCR0, lengthDescr0);
                                  USBUART_CyDmaSetNumDataElements(channelNum, USBUART_DMA_DESCR1, lengthDescr1);
              
                                  /* Validate descriptor 0 and command to start with it. */
                                  USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
                                  USBUART_CyDmaSetDescriptor0Next(channelNum);
              
                                  /* Enable DMA channel: configuration complete. */
                                  USBUART_CyDmaChEnable(channelNum);
              
                              #elif (USBUART_EP_DMA_AUTO_OPT == 0u)
                                  USBUART_inLength[epNumber]  = length;
                                  USBUART_inBufFull[epNumber] = 0u;
              
                                  (void) CyDmaChDisable(USBUART_DmaChan[epNumber]);
                                  /* Configure DMA to send data only for first burst. */
                                  (void) CyDmaTdSetConfiguration(
                                      USBUART_DmaTd[epNumber], (length > USBUART_DMA_BYTES_PER_BURST) ?
                                      USBUART_DMA_BYTES_PER_BURST : length,
                                      USBUART_DmaNextTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR );
                                  (void) CyDmaTdSetAddress(USBUART_DmaTd[epNumber], LO16((uint32)  USBUART_inDataPointer
             -[epNumber]),
                                                                                             LO16((uint32) &USBUART_ARB_
             -EP_BASE.arbEp[epNumber].rwDr));
                                  /* Clear Any potential pending DMA requests before starting DMA channel to transfer da
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 27  

             -ta. */
                                  (void) CyDmaClearPendingDrq(USBUART_DmaChan[epNumber]);
                                  /* Enable DMA. */
                                  (void) CyDmaChSetInitialTd(USBUART_DmaChan[epNumber], USBUART_DmaTd[epNumber]);
                                  (void) CyDmaChEnable(USBUART_DmaChan[epNumber], 1u);
                              #endif /* (CY_PSOC4) */
              
                              #if !defined (USBUART_MANUAL_IN_EP_ARM)
                                  /* Set IN data ready to generate DMA request to load data into endpoint buffer. */
                                  USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg |= USBUART_ARB_EPX_CFG_IN_DATA_RDY;
                              #endif  /* (USBUART_MANUAL_IN_EP_ARM) */
              
                                  /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer 
             -has been completed. */
                              }
                              else
                              {
                                  /* When zero-length packet: arm IN endpoint directly. */
                                  USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_EP[epNumber].epMode;
                              }
                          }
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USBUART_EP_MANAGEMENT_MANUAL) */
1585   2          }
1586   1      }
1587          
1588          
1589          /*******************************************************************************
1590          * Function Name: USBUART_ReadOutEP
1591          ****************************************************************************//**
1592          *
1593          *   This function performs different functionality depending on the Component’s
1594          *   configured Endpoint Buffer Management. This parameter is defined in the
1595          *   Descriptor Root in Component Configure window.
1596          *
1597          *   *Manual (Static/Dynamic Allocation):*
1598          *   This function moves the specified number of bytes from endpoint buffer to
1599          *   system RAM. The number of bytes actually transferred from endpoint buffer to
1600          *   system RAM is the lesser of the actual number of bytes sent by the host or
1601          *   the number of bytes requested by the length parameter.
1602          *
1603          *   *DMA with Manual Buffer Management:*
1604          *   Configure DMA to transfer data from endpoint buffer to system RAM. Generate
1605          *   a DMA request. The firmware must wait until the DMA completes the data
1606          *   transfer after calling the USBUART_ReadOutEP() API. For example,
1607          *   by checking EPstate:
1608          *
1609          *   \snippet /USBFS_sut_02.cydsn/main.c checking EPstatey
1610          *
1611          *   The USBFS_EnableOutEP() has to be called to allow host to write data into
1612          *   the endpoint buffer after DMA has completed transfer data from OUT endpoint
1613          *   buffer to SRAM.
1614          *
1615          *   *DMA with Automatic Buffer Management:*
1616          *   Configure DMA. This is required only once and automatically generates DMA
1617          *   requests as data arrives
1618          *
1619          *  \param epNumber: Contains the data endpoint number.
1620          *            Valid values are between 1 and 8.
1621          *  \param pData: A pointer to a data array from which the data for the endpoint
1622          *         space is loaded.
1623          *  \param length: The number of bytes to transfer from the USB Out endpoint and
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 28  

1624          *          loads it into data array. Valid values are between 0 and 1023. The
1625          *          function moves fewer than the requested number of bytes if the host
1626          *          sends fewer bytes than requested.
1627          *
1628          * \return
1629          *  Number of bytes received, 0 for an invalid endpoint.
1630          *
1631          * \reentrant
1632          *  No.
1633          *
1634          *******************************************************************************/
1635          uint16 USBUART_ReadOutEP(uint8 epNumber, uint8 pData[], uint16 length)
1636                                                                                  
1637          {
1638   1          if ((pData != NULL) && (epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
1639   1          {
1640   2          #if (!USBUART_EP_MANAGEMENT_DMA_AUTO)
1641   2              /* Adjust requested length to available data. */
1642   2              length = (length > USBUART_GetEPCount(epNumber)) ? USBUART_GetEPCount(epNumber) : length;
1643   2          #endif /* (!USBUART_EP_MANAGEMENT_DMA_AUTO) */
1644   2      
1645   2          #if (USBUART_EP_MANAGEMENT_MANUAL)
1646   2              {
1647   3                  /* Copy data using arbiter data register. */
1648   3                  uint16 i;
1649   3                  for (i = 0u; i < length; ++i)
1650   3                  {
1651   4                      pData[i] = (uint8) USBUART_ARB_EP_BASE.arbEp[epNumber].rwDr;
1652   4                  }
1653   3              }
1654   2      
1655   2              /* Arm OUT endpoint after data has been copied from endpoint buffer. */
1656   2              USBUART_EnableOutEP(epNumber);
1657   2          #else
              
                      #if (CY_PSOC3 || CY_PSOC5LP)
                          /* Initialize DMA if it was not initialized. */
                          if (DMA_INVALID_TD == USBUART_DmaTd[epNumber])
                          {
                              USBUART_InitEP_DMA(epNumber, pData);
                          }
                      #endif /* (CY_PSOC3 || CY_PSOC5LP) */
              
                      #if (USBUART_EP_MANAGEMENT_DMA_MANUAL)
                      #if (CY_PSOC4)
                      {
                          uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                          /* Disable DMA channel: start configuration. */
                          USBUART_CyDmaChDisable(channelNum);
              
                          /* Configure source and destination. */
                          USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP_BASE.arbEp[
             -epNumber].rwDr);
                          USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) pData);
              
                          /* Configure DMA descriptor. */
                          USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG | (uint16
             -)(length - 1u) |
                                                                  CYDMA_BYTE | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_ADDR |
             - CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 29  

                          /* Validate descriptor to execute on following DMA request. */
                          USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
              
                          /* Enable DMA channel: configuration complete. */
                          USBUART_CyDmaChEnable(channelNum);
                      }
                      #else
                          /* Configure DMA to transfer data. */
                          (void) CyDmaChDisable(USBUART_DmaChan[epNumber]);
                          (void) CyDmaTdSetConfiguration(USBUART_DmaTd[epNumber], length, CY_DMA_DISABLE_TD, TD_TERMIN_E
             -N | TD_INC_DST_ADR);
                          (void) CyDmaTdSetAddress(USBUART_DmaTd[epNumber], LO16((uint32) &USBUART_ARB_EP_BASE.arbEp[epN
             -umber].rwDr), LO16((uint32)pData));
              
                          /* Enable DMA channel. */
                          (void) CyDmaChSetInitialTd(USBUART_DmaChan[epNumber], USBUART_DmaTd[epNumber]);
                          (void) CyDmaChEnable(USBUART_DmaChan[epNumber], 1u);
                      #endif /* (CY_PSOC4) */
              
                          /* Generate DMA request. */
                          USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint8)  USBUART_ARB_EPX_CFG_DMA_REQ;
                          USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint8) ~USBUART_ARB_EPX_CFG_DMA_REQ;
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
              
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
                      #if (CY_PSOC4)
                      {
                          uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
                          uint32 lengthDescr0, lengthDescr1;
              
                          /* Get number of full bursts. */
                          USBUART_DmaEpBurstCnt[epNumber] = (uint8) (length / USBUART_DMA_BYTES_PER_BURST);
              
                          /* Get number of elements in the last burst. */
                          USBUART_DmaEpLastBurstEl[epNumber] = (uint8) (length % USBUART_DMA_BYTES_PER_BURST);
              
                          /* Get total number of bursts. */
                          USBUART_DmaEpBurstCnt[epNumber] += (0u != USBUART_DmaEpLastBurstEl[epNumber]) ? 1u : 0u;
              
                          /* Adjust number of the data elements transfered in last burst. */
                          USBUART_DmaEpLastBurstEl[epNumber] = (0u != USBUART_DmaEpLastBurstEl[epNumber]) ?
                                                                                (USBUART_DmaEpLastBurstEl[epNumber] - 1u
             -) :
                                                                                (USBUART_DMA_BYTES_PER_BURST - 1u);
              
                          /* Get number of data elements to transfer for descriptor 0 and 1. */
                          lengthDescr0 = (1u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNumber] : 
             -(USBUART_DMA_BYTES_PER_BURST - 1u);
                          lengthDescr1 = (2u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNumber] : 
             -(USBUART_DMA_BYTES_PER_BURST - 1u);
              
                          /* Mark if revert number of data elements in descriptor after transfer completion. */
                          USBUART_DmaEpLastBurstEl[epNumber] |= (USBUART_DmaEpBurstCnt[epNumber] > 2u) ? USBUART_DMA_DES
             -CR_REVERT : 0u;
              
                          /* Mark last descriptor to be executed. */
                          USBUART_DmaEpLastBurstEl[epNumber] |= (0u != (USBUART_DmaEpBurstCnt[epNumber] & 0x1u)) ?
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 30  

                                                                                  USBUART_DMA_DESCR0_MASK : USBUART_DMA_
             -DESCR1_MASK;
              
                          /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger after val
             -id descriptor were executed. */
                          USBUART_DmaEpBurstCnt[epNumber] = USBUART_DMA_GET_BURST_CNT(USBUART_DmaEpBurstCnt[epNumber]);
              
                          /* Store address of buffer and burst counter for endpoint. */
                          USBUART_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
                          USBUART_DmaEpBurstCntBackup[epNumber]   = USBUART_DmaEpBurstCnt[epNumber];
              
                          /* Disable DMA channel: start configuration. */
                          USBUART_CyDmaChDisable(channelNum);
              
                          /* Set destination address. */
                          USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP_BASE.arbEp[
             -epNumber].rwDr);
                          USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR1, (void*) &USBUART_ARB_EP_BASE.arbEp[
             -epNumber].rwDr);
              
                          USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) ((uint32) pData));
                          USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR1, (void*) ((uint32) pData + USBUART_D
             -MA_BYTES_PER_BURST));
              
                          /* Configure DMA descriptor. */
                          USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG  | length
             -Descr0 |
                                                                  CYDMA_BYTE | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_ADDR |
             - CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                          /* Configure DMA descriptor. */
                          USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR1, USBUART_DMA_COMMON_CFG  | length
             -Descr1 |
                                                                  CYDMA_BYTE | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_ADDR |
             - CYDMA_CHAIN);
              
                          /* Enable interrupt from DMA channel. */
                          USBUART_CyDmaSetInterruptMask(channelNum);
              
                          /* Validate DMA descriptor 0 and 1. */
                          USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
                          USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR1);
              
                          /* Enable DMA channel: configuration complete. */
                          USBUART_CyDmaChEnable(channelNum);
                      }
                      #else
                          (void) CyDmaChDisable(USBUART_DmaChan[epNumber]);
                          (void) CyDmaTdSetConfiguration(USBUART_DmaTd[epNumber], length,  USBUART_DmaTd[epNumber], TD_T
             -ERMIN_EN | TD_INC_DST_ADR);
                          (void) CyDmaTdSetAddress(USBUART_DmaTd[epNumber], LO16((uint32) &USBUART_ARB_EP_BASE.arbEp[epN
             -umber].rwDr), LO16((uint32) pData));
              
                          /* Clear Any potential pending DMA requests before starting DMA channel to transfer data. */
                          (void) CyDmaClearPendingDrq(USBUART_DmaChan[epNumber]);
              
                          /* Enable DMA channel. */
                          (void) CyDmaChSetInitialTd(USBUART_DmaChan[epNumber], USBUART_DmaTd[epNumber]);
                          (void) CyDmaChEnable(USBUART_DmaChan[epNumber], 1u);
                      #endif /* (CY_PSOC4) */
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 31  

                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
              
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USBUART_EP_MANAGEMENT_MANUAL) */
1795   2          }
1796   1          else
1797   1          {
1798   2              length = 0u;
1799   2          }
1800   1      
1801   1          return (length);
1802   1      }
1803          
1804          
1805          #if (USBUART_16BITS_EP_ACCESS_ENABLE)
              /*******************************************************************************
              * Function Name: USBUART_LoadInEP16
              ****************************************************************************//**
              *
              *  This function performs different functionality depending on the Component’s
              *  configured Endpoint Buffer Management. This parameter is defined in
              *  the Descriptor Root in Component Configure window.
              *
              *  *Manual (Static/Dynamic Allocation):*
              *  This function loads and enables the specified USB data endpoint for an IN
              *  data transfer.
              *
              *  *DMA with Manual Buffer Management:*
              *  Configures DMA for a data transfer from system RAM to endpoint buffer.
              *  Generates request for a transfer.
              *
              *  *DMA with Automatic Buffer Management:*
              *  Configures DMA. This is required only once, so it is done only when parameter
              *  pData is not NULL. When the pData pointer is NULL, the function skips this
              *  task. Sets Data ready status: This generates the first DMA transfer and
              *  prepares data in endpoint buffer.
              *
              *  \param epNumber Contains the data endpoint number.
              *        Valid values are between 1 and 8.
              *  \param *pData A pointer to a data array from which the data for the endpoint
              *        space is loaded. It shall be ensured that this pointer address is even
              *        to ensure the 16-bit transfer is aligned to even address. Else, a hard
              *        fault condition can occur.
              *  \param length The number of bytes to transfer from the array and then send as
              *        a result of an IN request. Valid values are between 0 and 512 (1023 for
              *        DMA with Automatic Buffer Management mode). The value 512 is applicable
              *        if only one endpoint is used.
              *
              * \reentrant
              *  No.
              *
              *******************************************************************************/
              void USBUART_LoadInEP16(uint8 epNumber, const uint8 pData[], uint16 length)
              {
                  /* Check array alignment on half-word boundary. */
                  CYASSERT(0u == (((uint32) pData) & 0x01u));
              
                  if ((epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
                  {
                  #if (!USBUART_EP_MANAGEMENT_DMA_AUTO)
                      /* Limit length to available buffer USB IP buffer size. */
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 32  

                      if (length > (USBUART_EPX_DATA_BUF_MAX - USBUART_EP[epNumber].buffOffset))
                      {
                          length = USBUART_EPX_DATA_BUF_MAX - USBUART_EP[epNumber].buffOffset;
                      }
                  #endif /* (!USBUART_EP_MANAGEMENT_DMA_AUTO) */
              
                      /* Set count and data toggle. */
                      USBUART_SIE_EP_BASE.sieEp[epNumber].epCnt0 = (uint32) HI8(length) | USBUART_EP[epNumber].epToggle;
                      USBUART_SIE_EP_BASE.sieEp[epNumber].epCnt1 = (uint32) LO8(length);
              
                      /* Adjust requested length: 2 bytes are handled at one data register access. */
                      length += (length & 0x01u);
              
                  #if (USBUART_EP_MANAGEMENT_MANUAL)
                      if (NULL != pData)
                      {
                          /* Convert uint8 array to uint16. */
                          const uint16 *dataBuf = (uint16 *) pData;
              
                          /* Copy data using 16-bits arbiter data register. */
                          uint16 i;
                          for (i = 0u; i < (length >> 1u); ++i)
                          {
                              USBUART_ARB_EP16_BASE.arbEp[epNumber].rwDr16 = dataBuf[i];
                          }
                      }
              
                      /* IN endpoint buffer is full - read to be read. */
                      USBUART_EP[epNumber].apiEpState = USBUART_NO_EVENT_PENDING;
              
                      /* Arm IN endpoint. */
                      USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_EP[epNumber].epMode;
              
                  #else
              
                      #if (USBUART_EP_MANAGEMENT_DMA_MANUAL)
                          /* IN endpoint buffer will be fully loaded by DMA shortly. */
                          USBUART_EP[epNumber].apiEpState = USBUART_NO_EVENT_PENDING;
              
                          if ((pData != NULL) && (length > 0u))
                          {
                              uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                              /* Disable DMA channel: start configuration. */
                              USBUART_CyDmaChDisable(channelNum);
              
                              /* Configure source and destination. */
                              USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) pData);
                              USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP16_BASE.
             -arbEp[epNumber].rwDr16);
              
                              /* Configure DMA descriptor. */
                              length = (length >> 1u) - 1u;
                              USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG | len
             -gth |
                                                                      CYDMA_HALFWORD | CYDMA_ELEMENT_WORD | CYDMA_INC_SR
             -C_ADDR | CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
                              /* Validate descriptor to execute on following DMA request. */
                              USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
              
                              /* Enable DMA channel: configuration complete. */
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 33  

                              USBUART_CyDmaChEnable(channelNum);
              
                              /* Generate DMA request. */
                              USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint32)  USBUART_ARB_EPX_CFG_DMA_REQ;
                              USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint32) ~USBUART_ARB_EPX_CFG_DMA_REQ;
              
                              /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer has 
             -been completed. */
                          }
                          else
                          {
                              /* When zero-length packet: arm IN endpoint directly. */
                              USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_EP[epNumber].epMode;
                          }
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
                          if (pData != NULL)
                          {
                              uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                              /* Store address of buffer. */
                              USBUART_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
              
                              /* Disable DMA channel: start configuration. */
                              USBUART_CyDmaChDisable(channelNum);
              
                              /* Set destination address. */
                              USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP16_BASE.
             -arbEp[epNumber].rwDr16);
                              USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR1, (void*) &USBUART_ARB_EP16_BASE.
             -arbEp[epNumber].rwDr16);
              
                              /* Configure DMA descriptor. */
                              USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG  |
                                                                      CYDMA_HALFWORD | CYDMA_ELEMENT_WORD | CYDMA_INC_SR
             -C_ADDR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                              /* Configure DMA descriptor. */
                              USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR1, USBUART_DMA_COMMON_CFG  |
                                                                      CYDMA_HALFWORD | CYDMA_ELEMENT_WORD | CYDMA_INC_SR
             -C_ADDR | CYDMA_CHAIN);
              
                              /* Enable interrupt from DMA channel. */
                              USBUART_CyDmaSetInterruptMask(channelNum);
              
                              /* Validate descriptor 1. It will not be invalided during operation. */
                              USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR1);
              
                              /* Enable DMA channel: configuration complete. */
                              USBUART_CyDmaChEnable(channelNum);
                          }
                          else
                          {
                              /* IN endpoint buffer (32 bytes) will shortly be preloaded by DMA. */
                              USBUART_EP[epNumber].apiEpState = USBUART_NO_EVENT_PENDING;
              
                              if (length > 0u)
                              {
                                  uint32 lengthDescr0, lengthDescr1;
                                  uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 34  

                                  /* Get number of full bursts. */
                                  USBUART_DmaEpBurstCnt[epNumber] = (uint8) (length / USBUART_DMA_BYTES_PER_BURST);
              
                                  /* Get number of elements in the last burst. */
                                  USBUART_DmaEpLastBurstEl[epNumber] = (uint8) (length % USBUART_DMA_BYTES_PER_BURST);
              
                                  /* Get total number of bursts. */
                                  USBUART_DmaEpBurstCnt[epNumber] += (0u != USBUART_DmaEpLastBurstEl[epNumber]) ? 1u : 0
             -u;
              
                                  /* Adjust number of data elements transferred in last burst. */
                                  USBUART_DmaEpLastBurstEl[epNumber] = (0u != USBUART_DmaEpLastBurstEl[epNumber]) ?
                                                                                        ((USBUART_DmaEpLastBurstEl[epNum
             -ber] >> 1u) - 1u) :
                                                                                         (USBUART_DMA_HALFWORDS_PER_BURS
             -T - 1u);
              
                                  /* Get number of data elements to transfer for descriptor 0 and 1. */
                                  lengthDescr0 = (1u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNu
             -mber] : (USBUART_DMA_HALFWORDS_PER_BURST - 1u);
                                  lengthDescr1 = (2u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNu
             -mber] : (USBUART_DMA_HALFWORDS_PER_BURST - 1u);
              
                                  /* Mark which descriptor is last one to execute. */
                                  USBUART_DmaEpLastBurstEl[epNumber] |= (0u != (USBUART_DmaEpBurstCnt[epNumber] & 0x1u))
             - ?
                                                                                          USBUART_DMA_DESCR0_MASK : USBU
             -ART_DMA_DESCR1_MASK;
              
                                  /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger a
             -fter valid descriptor were executed. */
                                  USBUART_DmaEpBurstCnt[epNumber] = USBUART_DMA_GET_BURST_CNT(USBUART_DmaEpBurstCnt[epNu
             -mber]);
              
                                  /* Restore DMA settings for current transfer. */
                                  USBUART_CyDmaChDisable(channelNum);
              
                                  /* Restore destination address for input endpoint. */
                                  USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) ((uint32) USBUART_D
             -maEpBufferAddrBackup[epNumber]));
                                  USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR1, (void*) ((uint32) USBUART_D
             -maEpBufferAddrBackup[epNumber] +
                                                                                                                        
             -         USBUART_DMA_BYTES_PER_BURST));
              
                                  /* Set number of elements to transfer. */
                                  USBUART_CyDmaSetNumDataElements(channelNum, USBUART_DMA_DESCR0, lengthDescr0);
                                  USBUART_CyDmaSetNumDataElements(channelNum, USBUART_DMA_DESCR1, lengthDescr1);
              
                                  /* Validate descriptor 0 and command to start with it. */
                                  USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
                                  USBUART_CyDmaSetDescriptor0Next(channelNum);
              
                                  /* Enable DMA channel: configuration complete. */
                                  USBUART_CyDmaChEnable(channelNum);
              
                              #if !defined (USBUART_MANUAL_IN_EP_ARM)
                                  /* Set IN data ready to generate DMA request to load data into endpoint buffer. */
                                  USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg |= USBUART_ARB_EPX_CFG_IN_DATA_RDY;
                              #endif  /* (USBUART_MANUAL_IN_EP_ARM) */
              
                                  /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer 
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 35  

             -has been completed. */
                              }
                              else
                              {
                                  /* When zero-length packet: arm IN endpoint directly. */
                                  USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_EP[epNumber].epMode;
                              }
                          }
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USBUART_EP_MANAGEMENT_MANUAL) */
                  }
              }
              
              
              /*******************************************************************************
              * Function Name: USBUART_ReadOutEP16
              ****************************************************************************//**
              *
              *   This function performs different functionality depending on the Component’s
              *   configured Endpoint Buffer Management. This parameter is defined in the
              *   Descriptor Root in Component Configure window.
              *
              *   *Manual (Static/Dynamic Allocation):*
              *   This function moves the specified number of bytes from endpoint buffer to
              *   system RAM. The number of bytes actually transferred from endpoint buffer to
              *   system RAM is the lesser of the actual number of bytes sent by the host or
              *   the number of bytes requested by the length parameter.
              *
              *   *DMA with Manual Buffer Management:*
              *   Configure DMA to transfer data from endpoint buffer to system RAM. Generate
              *   a DMA request. The firmware must wait until the DMA completes the data
              *   transfer after calling the USBUART_ReadOutEP() API. For example,
              *   by checking EPstate:
              *
              *   \snippet /USBFS_sut_02.cydsn/main.c checking EPstatey
              *
              *   The USBFS_EnableOutEP() has to be called to allow host to write data into
              *   the endpoint buffer after DMA has completed transfer data from OUT endpoint
              *   buffer to SRAM.
              *
              *   *DMA with Automatic Buffer Management:*
              *   Configure DMA. This is required only once and automatically generates DMA
              *   requests as data arrives
              *
              *  \param epNumber: Contains the data endpoint number.
              *         Valid values are between 1 and 8.
              *  \param pData: A pointer to a data array into which the data for the endpoint
              *         space is copied. It shall be ensured that this pointer address is
              *         even to ensure the 16-bit transfer is aligned to even address. Else,
              *         a hard fault condition can occur.
              *  \param length: The number of bytes to transfer from the USB Out endpoint and
              *         loads it into data array. Valid values are between 0 and 1023. The
              *         function moves fewer than the requested number of bytes if the host
              *         sends fewer bytes than requested.
              *
              * \return
              *  Number of bytes received, 0 for an invalid endpoint.
              *
              * \reentrant
              *  No.
              *
              *******************************************************************************/
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 36  

              uint16 USBUART_ReadOutEP16(uint8 epNumber, uint8 pData[], uint16 length)
              {
                  uint32 adjLength;
              
                  /* Check array alignment on half-word boundary */
                  CYASSERT(0u == (((uint32) pData) & 0x01u));
              
                  if ((pData != NULL) && (epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
                  {
                  #if (!USBUART_EP_MANAGEMENT_DMA_AUTO)
                      /* Adjust requested length to available data. */
                      length = (length > USBUART_GetEPCount(epNumber)) ? USBUART_GetEPCount(epNumber) : length;
                  #endif /* (!USBUART_EP_MANAGEMENT_DMA_AUTO) */
              
                  /* Adjust requested length: 2 bytes are handled at one data register access. */
                  adjLength =  length + ((uint32)length & 1u);
              
                  #if (USBUART_EP_MANAGEMENT_MANUAL)
                      {
                          /* Convert uint8 array to uint16. */
                          uint16 *dataBuf = (uint16 *) pData;
              
                          /* Copy data using 16-bits arbiter data register. */
                          uint16 i;
                          for (i = 0u; i < (adjLength >> 1u); ++i)
                          {
                              dataBuf[i] = (uint16) USBUART_ARB_EP16_BASE.arbEp[epNumber].rwDr16;
                          }
                      }
              
                      /* Arm OUT endpoint after data has been read from endpoint buffer. */
                      USBUART_EnableOutEP(epNumber);
                  #else
              
                      #if (USBUART_EP_MANAGEMENT_DMA_MANUAL)
                      {
                          uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                          /* Disable DMA channel: start configuration. */
                          USBUART_CyDmaChDisable(channelNum);
              
                          /* Configure source and destination. */
                          USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP16_BASE.arbE
             -p[epNumber].rwDr16);
                          USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) pData);
              
                          /* Configure DMA descriptor. */
                          USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG | (uint16
             -)((adjLength >> 1u) - 1u) |
                                                                  CYDMA_HALFWORD | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_AD
             -DR | CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
                          /* Validate descriptor to execute on following DMA request. */
                          USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
              
                          /* Enable DMA channel: configuration complete. */
                          USBUART_CyDmaChEnable(channelNum);
              
                          /* Generate DMA request. */
                          USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint32)  USBUART_ARB_EPX_CFG_DMA_REQ;
                          USBUART_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint32) ~USBUART_ARB_EPX_CFG_DMA_REQ;
              
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 37  

                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
                      }
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
                      {
                          uint32 lengthDescr0, lengthDescr1;
                          uint32 channelNum = (uint32) USBUART_DmaChan[epNumber];
              
                          /* Get number of full bursts. */
                          USBUART_DmaEpBurstCnt[epNumber] = (uint8) (adjLength / USBUART_DMA_BYTES_PER_BURST);
              
                          /* Get number of elements in last burst. */
                          USBUART_DmaEpLastBurstEl[epNumber] = (uint8) (adjLength % USBUART_DMA_BYTES_PER_BURST);
              
                          /* Get total number of bursts. */
                          USBUART_DmaEpBurstCnt[epNumber] += (0u != USBUART_DmaEpLastBurstEl[epNumber]) ? 1u : 0u;
              
                          /* Adjust number of data elements transferred in last burst. */
                          USBUART_DmaEpLastBurstEl[epNumber] = (0u != USBUART_DmaEpLastBurstEl[epNumber]) ?
                                                                                ((USBUART_DmaEpLastBurstEl[epNumber] >> 
             -1u) - 1u) :
                                                                                 (USBUART_DMA_HALFWORDS_PER_BURST - 1u);
              
                          /* Get number of data elements to transfer for descriptor 0 and 1. */
                          lengthDescr0 = (1u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNumber] : 
             -(USBUART_DMA_HALFWORDS_PER_BURST - 1u);
                          lengthDescr1 = (2u == USBUART_DmaEpBurstCnt[epNumber]) ? USBUART_DmaEpLastBurstEl[epNumber] : 
             -(USBUART_DMA_HALFWORDS_PER_BURST - 1u);
              
                          /* Mark last descriptor to be executed. */
                          USBUART_DmaEpLastBurstEl[epNumber] |= (0u != (USBUART_DmaEpBurstCnt[epNumber] & 0x1u)) ?
                                                                                  USBUART_DMA_DESCR0_MASK : USBUART_DMA_
             -DESCR1_MASK;
              
                          /* Mark if revert number of data elements in descriptor after transfer completion. */
                          USBUART_DmaEpLastBurstEl[epNumber] |= (USBUART_DmaEpBurstCnt[epNumber] > 2u) ? USBUART_DMA_DES
             -CR_REVERT : 0u;
              
                          /* Mark that 16-bits access to data register is performed. */
                          USBUART_DmaEpLastBurstEl[epNumber] |= USBUART_DMA_DESCR_16BITS;
              
                          /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger after val
             -id descriptor were executed. */
                          USBUART_DmaEpBurstCnt[epNumber] = USBUART_DMA_GET_BURST_CNT(USBUART_DmaEpBurstCnt[epNumber]);
              
                          /* Store address of buffer and burst counter for endpoint. */
                          USBUART_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
                          USBUART_DmaEpBurstCntBackup[epNumber]   = USBUART_DmaEpBurstCnt[epNumber];
              
                          /* Disable DMA channel: start configuration. */
                          USBUART_CyDmaChDisable(channelNum);
              
                          /* Set destination address. */
                          USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR0, (void*) &USBUART_ARB_EP16_BASE.arbE
             -p[epNumber].rwDr16);
                          USBUART_CyDmaSetSrcAddress(channelNum, USBUART_DMA_DESCR1, (void*) &USBUART_ARB_EP16_BASE.arbE
             -p[epNumber].rwDr16);
              
                          USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) ((uint32) pData));
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 38  

                          USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR1, (void*) ((uint32) pData + USBUART_D
             -MA_BYTES_PER_BURST));
              
                          /* Configure DMA descriptor 0. */
                          USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR0, USBUART_DMA_COMMON_CFG  | length
             -Descr0 |
                                                                  CYDMA_HALFWORD | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_AD
             -DR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                          /* Configure DMA descriptor 1. */
                          USBUART_CyDmaSetConfiguration(channelNum, USBUART_DMA_DESCR1, USBUART_DMA_COMMON_CFG  | length
             -Descr1 |
                                                                  CYDMA_HALFWORD | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_AD
             -DR | CYDMA_CHAIN);
              
                          /* Enable interrupt from DMA channel. */
                          USBUART_CyDmaSetInterruptMask(channelNum);
              
                          /* Validate DMA descriptor 0 and 1. */
                          USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
                          USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR1);
              
                          /* Enable DMA channel: configuration complete. */
                          USBUART_CyDmaChEnable(channelNum);
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
                      }
                      #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USBUART_EP_MANAGEMENT_MANUAL) */
                  }
                  else
                  {
                      length = 0u;
                  }
              
                  return (length);
              }
              #endif /* (USBUART_16BITS_EP_ACCESS_ENABLE) */
2227          
2228          
2229          /*******************************************************************************
2230          * Function Name: USBUART_EnableOutEP
2231          ****************************************************************************//**
2232          *
2233          *  This function enables the specified endpoint for OUT transfers. Do not call
2234          *  this function for IN endpoints.
2235          *
2236          *  \param epNumber: Contains the data endpoint number. Valid values are between
2237          *  1 and 8.
2238          *
2239          * \globalvars
2240          *
2241          *  \ref USBUART_EP[epNumber].apiEpState - set to NO_EVENT_PENDING
2242          *
2243          * \reentrant
2244          *  No.
2245          *
2246          *******************************************************************************/
2247          void USBUART_EnableOutEP(uint8 epNumber) 
2248          {
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 39  

2249   1          if ((epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
2250   1          {
2251   2              USBUART_EP[epNumber].apiEpState = USBUART_NO_EVENT_PENDING;
2252   2      
2253   2              /* Enable OUT endpoint to be written by Host. */
2254   2              USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_EP[epNumber].epMode;
2255   2              
2256   2          }
2257   1      }
2258          
2259          
2260          /*******************************************************************************
2261          * Function Name: USBUART_DisableOutEP
2262          ****************************************************************************//**
2263          *
2264          *  This function disables the specified USBFS OUT endpoint. Do not call this
2265          *  function for IN endpoints.
2266          *
2267          *  \param epNumber: Contains the data endpoint number.
2268          *            Valid values are between 1 and 8.
2269          *
2270          *******************************************************************************/
2271          void USBUART_DisableOutEP(uint8 epNumber) 
2272          {
2273   1          if ((epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
2274   1          {
2275   2              /* Set NAK response for OUT endpoint. */
2276   2              USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBUART_MODE_NAK_OUT;
2277   2          }
2278   1      }
2279          
2280          
2281          /*******************************************************************************
2282          * Function Name: USBUART_Force
2283          ****************************************************************************//**
2284          *
2285          *  This function forces a USB J, K, or SE0 state on the D+/D– lines. It provides
2286          *  the necessary mechanism for a USB device application to perform a USB Remote
2287          *  Wakeup. For more information, see the USB 2.0 Specification for details on
2288          *  Suspend and Resume.
2289          *
2290          *  \param state A byte indicating which of the four bus states to enable.
2291          *        Symbolic names  and their associated values are listed here:
2292          *    State                      |Description
2293          *    ---------------------------|----------------------------------------------
2294          *    USBUART_FORCE_J   | Force a J State onto the D+/D– lines
2295          *    USBUART_FORCE_K   | Force a K State onto the D+/D– lines
2296          *    USBUART_FORCE_SE0 | Force a Single Ended 0 onto the D+/D– lines
2297          *    USBUART_FORCE_NONE| Return bus to SIE control
2298          *
2299          *
2300          *******************************************************************************/
2301          void USBUART_Force(uint8 bState) 
2302          {
2303   1          /* This registers is used only for manual control of SIE (no masking is
2304   1          * needed before write into it).
2305   1          */
2306   1          USBUART_USBIO_CR0_REG = bState;
2307   1      }
2308          
2309          
2310          /*******************************************************************************
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 40  

2311          * Function Name: USBUART_GetEPAckState
2312          ****************************************************************************//**
2313          *
2314          *  This function determines whether an ACK transaction occurred on this endpoint
2315          *  by reading the ACK bit in the control register of the endpoint. It does not
2316          *  clear the ACK bit.
2317          *
2318          *  \param epNumber Contains the data endpoint number.
2319          *            Valid values are between 1 and 8.
2320          *
2321          *  \return
2322          *  If an ACKed transaction occurred, this function returns a non-zero value.
2323          *  Otherwise, it returns zero.
2324          *
2325          *******************************************************************************/
2326          uint8 USBUART_GetEPAckState(uint8 epNumber) 
2327          {
2328   1          uint8 cr = 0u;
2329   1      
2330   1          if ((epNumber > USBUART_EP0) && (epNumber < USBUART_MAX_EP))
2331   1          {
2332   2              cr = USBUART_SIE_EP_BASE.sieEp[epNumber].epCr0 & USBUART_MODE_ACKD;
2333   2          }
2334   1      
2335   1          return ((uint8) cr);
2336   1      }
2337          
2338          
2339          /*******************************************************************************
2340          * Function Name: USBUART_SetPowerStatus
2341          ****************************************************************************//**
2342          *
2343          *  This function sets the current power status. The device replies to USB
2344          *  GET_STATUS requests based on this value. This allows the device to properly
2345          *  report its status for USB Chapter 9 compliance. Devices can change their
2346          *  power source from self powered to bus powered at any time and report their
2347          *  current power source as part of the device status. You should call this
2348          *  function any time your device changes from self powered to bus powered or
2349          *  vice versa, and set the status appropriately.
2350          *
2351          *  \param powerStatus: Contains the desired power status, one for self powered
2352          *        or zero for bus powered. Symbolic names and their associated values are
2353          *        given here:
2354          *  Power Status                                |Description
2355          *  --------------------------------------------|---------------------------
2356          *  USBUART_DEVICE_STATUS_BUS_POWERED  | Set the device to bus powered
2357          *  USBUART_DEVICE_STATUS_SELF_POWERED | Set the device to self powered
2358          *
2359          * \globalvars
2360          *
2361          *  \ref USBUART_deviceStatus - set power status
2362          *
2363          * \reentrant
2364          *  No.
2365          *
2366          *******************************************************************************/
2367          void USBUART_SetPowerStatus(uint8 powerStatus) 
2368          {
2369   1          if (powerStatus != USBUART_DEVICE_STATUS_BUS_POWERED)
2370   1          {
2371   2              USBUART_deviceStatus |= (uint8)  USBUART_DEVICE_STATUS_SELF_POWERED;
2372   2          }
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 41  

2373   1          else
2374   1          {
2375   2              USBUART_deviceStatus &= (uint8) ~USBUART_DEVICE_STATUS_SELF_POWERED;
2376   2          }
2377   1      }
2378          
2379          
2380          #if (USBUART_VBUS_MONITORING_ENABLE)
                  /***************************************************************************
                  * Function Name: USBUART_VBusPresent
                  ************************************************************************//**
                  *
                  *  Determines VBUS presence for self-powered devices. This function is
                  *  available when the VBUS Monitoring option is enabled in the Advanced tab.
                  *
                  * \return
                  *  The return value can be the following:
                  *  Return Value | Description
                  *  -------------|-----------------
                  *  1            | VBUS is present
                  *  0            | VBUS is absent
                  *
                  *
                  ***************************************************************************/
                  uint8 USBUART_VBusPresent(void) 
                  {
                      return ((0u != (USBUART_VBUS_STATUS_REG & USBUART_VBUS_VALID)) ? (uint8) 1u : (uint8) 0u);
                  }
              #endif /* (USBUART_VBUS_MONITORING_ENABLE) */
2402          
2403          
2404          /*******************************************************************************
2405          * Function Name: USBUART_RWUEnabled
2406          ****************************************************************************//**
2407          *
2408          *  This function returns the current remote wakeup status.
2409          *  If the device supports remote wakeup, the application should use this
2410          *  function to determine if remote wakeup was enabled by the host. When the
2411          *  device is suspended and it determines the conditions to initiate a remote
2412          *  wakeup are met, the application should use the USBFS_Force() function to
2413          *  force the appropriate J and K states onto the USB bus, signaling a remote
2414          *  wakeup.
2415          *
2416          *
2417          * \return
2418          *  Returns non-zero value if remote wakeup is enabled and zero otherwise.
2419          *
2420          * \globalvars
2421          *  USBUART_deviceStatus - checked to determine remote status
2422          *
2423          *******************************************************************************/
2424          uint8 USBUART_RWUEnabled(void) 
2425          {
2426   1          uint8 result = USBUART_FALSE;
2427   1      
2428   1          if (0u != (USBUART_deviceStatus & USBUART_DEVICE_STATUS_REMOTE_WAKEUP))
2429   1          {
2430   2              result = USBUART_TRUE;
2431   2          }
2432   1      
2433   1          return (result);
2434   1      }
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 42  

2435          
2436          
2437          /*******************************************************************************
2438          * Function Name: USBUART_GetDeviceAddress
2439          ****************************************************************************//**
2440          *
2441          *  This function returns the currently assigned address for the USB device.
2442          *
2443          * \return
2444          *  Returns the currently assigned address.
2445          *  Returns 0 if the device has not yet been assigned an address.
2446          *
2447          *******************************************************************************/
2448          uint8 USBUART_GetDeviceAddress(void) 
2449          {
2450   1          return (uint8)(USBUART_CR0_REG & USBUART_CR0_DEVICE_ADDRESS_MASK);
2451   1      }
2452          
2453          
2454          /*******************************************************************************
2455          * Function Name: USBUART_EnableSofInt
2456          ****************************************************************************//**
2457          *
2458          *  This function enables interrupt generation when a Start-of-Frame (SOF)
2459          *  packet is received from the host.
2460          *
2461          *******************************************************************************/
2462          void USBUART_EnableSofInt(void) 
2463          {
2464   1      #if (CY_PSOC4)
                  /* Enable SOF interrupt interrupt source. */
                  USBUART_INTR_SIE_MASK_REG |= (uint32) USBUART_INTR_SIE_SOF_INTR;
              #else
2468   1          /* Enable SOF interrupt if it is present. */
2469   1          #if (USBUART_SOF_ISR_ACTIVE)
2470   1              CyIntEnable(USBUART_SOF_VECT_NUM);
2471   1          #endif /* (USBUART_SOF_ISR_ACTIVE) */
2472   1      #endif /* (CY_PSOC4) */
2473   1      }
2474          
2475          
2476          /*******************************************************************************
2477          * Function Name: USBUART_DisableSofInt
2478          ****************************************************************************//**
2479          *
2480          *  This function disables interrupt generation when a Start-of-Frame (SOF)
2481          *  packet is received from the host.
2482          *
2483          *******************************************************************************/
2484          void USBUART_DisableSofInt(void) 
2485          {
2486   1      #if (CY_PSOC4)
                  /* Disable SOF interrupt interrupt source. */
                  USBUART_INTR_SIE_MASK_REG &= (uint32) ~USBUART_INTR_SIE_SOF_INTR;
              #else
2490   1          /* Disable SOF interrupt if it is present. */
2491   1          #if (USBUART_SOF_ISR_ACTIVE)
2492   1              CyIntDisable(USBUART_SOF_VECT_NUM);
2493   1          #endif /* (USBUART_SOF_ISR_ACTIVE) */
2494   1      #endif /* (CY_PSOC4) */
2495   1      }
2496          
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 43  

2497          
2498          #if (USBUART_BATT_CHARG_DET_ENABLE)
                  /***************************************************************************
                  * Function Name: USBUART_DetectPortType
                  ************************************************************************//**
                  *
                  *   This function implements the USB  Battery Charger Detection (BCD)
                  *   algorithm to determine the type of USB host downstream port. This API
                  *   is available only for PSoC 4 devices, and should be called when the VBUS
                  *   voltage transition (OFF to ON) is detected on the bus. If the USB device
                  *   functionality is enabled, this API first calls USBFS_Stop() API
                  *   internally to disable the USB device functionality, and then proceeds to
                  *   implement the BCD algorithm to detect the USB host port type.
                  *   The USBFS_Start() API should be called after this API if the USB
                  *   communication needs to be initiated with the host.
                  *   *Note* This API is generated only if the “Enable Battery Charging 
                  *   Detection” option is enabled in the “Advanced” tab of the component GUI.
                  *   *Note* API implements the steps 2-4 of the BCD algorithm which are 
                  *   - Data Contact Detect
                  *   - Primary Detection 
                  *   - Secondary Detection 
                  * 
                  *   The first step of BCD algorithm, namely, VBUS detection shall be handled 
                  *   at the application firmware level.
                  *
                  * \return
                  *   The return value can be the following:
                  *   Return Value                      |Description
                  *   ----------------------------------|-------------------------------------
                  *   USBUART_BCD_PORT_SDP     | Standard downstream port detected
                  *   USBUART_BCD_PORT_CDP     | Charging downstream port detected
                  *   USBUART_BCD_PORT_DCP     | Dedicated charging port detected
                  *   USBUART_BCD_PORT_UNKNOWN | Unable to detect charging port type (proprietary charger type)
                  *   USBUART_BCD_PORT_ERR     | Error condition in detection process
                  *
                  *
                  * \sideeffects
                  *
                  *  USB device functionality is disabled by this API if not already disabled.
                  *
                  ***************************************************************************/
                  uint8 USBUART_Bcd_DetectPortType(void)
                  {
                      uint32 bkPwrCtrl;
                      uint32 cr1RegVal;
                      uint32 secondaryDetection = 0u;
                      uint8 result = USBUART_BCD_PORT_UNKNOWN;
              
                      /*Check USB Started and Stop it*/
                      if(0u != USBUART_initVar)
                      {
                          USBUART_Stop();
                      }
                      /*Initialize USBFS IP for Charger detection*/
              
                      /*Enable clock to USB IP. */
                      USBUART_USB_CLK_EN_REG = USBUART_USB_CLK_CSR_CLK_EN;
              
                      /* Enable USBIO control on drive mode of D+ and D- pins. */
                      USBUART_USBIO_CR1_REG &= ~ (uint32) USBUART_USBIO_CR1_IOMODE;
              
                      /* Select VBUS detection source and clear PHY isolate. The application
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 44  

                      *  level must ensure that VBUS is valid. There is no need to wait 2us
                      *  before VBUS is valid.
                      */
                      bkPwrCtrl = USBUART_POWER_CTRL_REG;
                      USBUART_POWER_CTRL_REG = USBUART_DEFAULT_POWER_CTRL_VBUS\
                                          & (~USBUART_POWER_CTRL_ENABLE_VBUS_PULLDOWN)\
                                          & (~USBUART_POWER_CTRL_ENABLE_DM_PULLDOWN);
              
              
                      /* Enable PHY detector and single-ended and differential receivers.
                       * Enable charger detection.  */
                      USBUART_POWER_CTRL_REG |= USBUART_DEFAULT_POWER_CTRL_PHY\
                                                       | USBUART_POWER_CTRL_ENABLE_CHGDET;
              
                      /* Suspend clear sequence. */
                      USBUART_POWER_CTRL_REG &= (uint32) ~USBUART_POWER_CTRL_SUSPEND;
                      CyDelayUs(USBUART_WAIT_SUSPEND_DEL_DISABLE);
                      USBUART_POWER_CTRL_REG &= (uint32) ~USBUART_POWER_CTRL_SUSPEND_DEL;
              
                      /* Data connection detection
                      * Realization with delay as Hard IP does not support DCD 300 ms.
                      */
                      #if defined (USBUART_NO_DCD)
                      CyDelay(USBUART_BCD_TIMEOUT);
                      #else
                      /* DCD implementation:*/
              
                      {
                          uint16 timeout = USBUART_BCD_TIMEOUT;
                          uint8 connectionApproved = 0u;
                          uint8 connected = 0u;
              
                          /*   BCD spec 1.2: Turns on Idp_src and D- pull-down resistor */
                          USBUART_POWER_CTRL_REG |= USBUART_POWER_CTRL_ENABLE_DM_PULLDOWN;
                          USBUART_CHGDET_CTRL_REG |= USBUART_CHGDET_CTRL_DCD_SRC_EN;
              
                          /* BCD spec 1.2: Waits for D+ to be low for a time of Tdcd_dbnc*/
                          while ((0u != timeout) && (0u == connectionApproved))
                          {
                              if (0u == (USBUART_USBIO_CR1_REG & USBUART_USBIO_CR1_DP0))
                              {
                                  connected++;
                              }
                              else
                              {
                                  connected = 0u;
                              }
                              connectionApproved = (USBUART_BCD_TDCD_DBNC < connected) ? 1u:0u;
                              CyDelay(1u);
                              timeout--;
                          }
              
                          /*   BCD spec 1.2: Turns off Idp_src. */
                          USBUART_CHGDET_CTRL_REG &= ~USBUART_CHGDET_CTRL_DCD_SRC_EN;
                      }
                      #endif /*(USBUART_NO_DCD)*/
              
                      /* Primary detection: enable VDP_SRC on D+ and IDM_SINK on D-. */
                      USBUART_CHGDET_CTRL_REG = USBUART_CHGDET_CTRL_PRIMARY;
                      CyDelay(USBUART_BCD_PRIMARY_WAIT);
                      cr1RegVal = USBUART_USBIO_CR1_REG;
              
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 45  

                      /* Check is it SDP or DCP/CDP, read comparator 2 output. */
                      if (0u == (USBUART_CHGDET_CTRL_REG & USBUART_CHGDET_CTRL_COMP_OUT))
                      {
                          /* Check status of D- line. */
                          if (0u == (cr1RegVal & USBUART_USBIO_CR1_DM0))
                          {
                              result = USBUART_BCD_PORT_SDP;
                          }
                          else
                          {
                              /* ERROR: such combination is impossible. Abort charger
                               * detection.
                              */
                              result = USBUART_BCD_PORT_ERR;
                          }
                      }
                      else
                      {
                              /* Need Secondary detection. Charging port: DCP or proprietary*/
                              secondaryDetection = 1u;
                      }
              
                      /* Secondary detection: Set CHGDET_CTRL register to enable VDM_SRC on D- and IDP_SINK on D+. */
              
                      if (0u != secondaryDetection)
                      {
                          USBUART_CHGDET_CTRL_REG = USBUART_CHGDET_CTRL_DEFAULT \
                                                              | USBUART_CHGDET_CTRL_SECONDARY;
                          CyDelay(USBUART_BCD_SECONDARY_WAIT);
                          cr1RegVal = USBUART_USBIO_CR1_REG;
              
                          /* Check is it SDP or DCP/CDP, read comparator 1 output. */
                          if (0u == (USBUART_CHGDET_CTRL_REG & USBUART_CHGDET_CTRL_COMP_OUT))
                          {
                              /* Check status of D+ line. */
                              if (0u == (cr1RegVal & USBUART_USBIO_CR1_DP0))
                              {
                                  result = USBUART_BCD_PORT_CDP;
                              }
                              else
                              {
                                  /* ERROR: such combination is impossible. Abort charger
                                   * detection.
                                  */
                                  result = USBUART_BCD_PORT_ERR;
                              }
                          }
                          else
                          {
                              /* Check status of D+ line. */
                              if (0u == (cr1RegVal & USBUART_USBIO_CR1_DP0))
                              {
                                  result = USBUART_BCD_PORT_DCP;
                              }
                              else
                              {
                                  /* It is may be proprietary charger. Proprietary charge is
                                   * not supported byHardware IP block.
                                  */
                                  result = USBUART_BCD_PORT_UNKNOWN;
                              }
                          }
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 46  

                      }
              
                      /* Restore CHGDET_CTRL. */
                      USBUART_CHGDET_CTRL_REG = 0u;
              
                      /*Revert registers back*/
                      USBUART_POWER_CTRL_REG = bkPwrCtrl;
                      USBUART_USBIO_CR1_REG |= (uint32) USBUART_USBIO_CR1_IOMODE;
                      USBUART_USB_CLK_EN_REG = ~USBUART_USB_CLK_CSR_CLK_EN;
              
                      return (result);
                  }
              #endif  /* (USBUART_BATT_CHARG_DET_ENABLE) */
2696          
2697          
2698          #if (USBUART_LPM_ACTIVE)
                  /***************************************************************************
                  * Function Name: USBUART_Lpm_GetBeslValue
                  ************************************************************************//**
                  *
                  *  This function returns the Best Effort Service Latency (BESL) value
                  *  sent by the host as part of the LPM token transaction.
                  *
                  * \return
                  *  4-bit BESL value received in the LPM token packet from the host
                  *
                  *
                  ***************************************************************************/
                  uint32 USBUART_Lpm_GetBeslValue(void)
                  {
                      return (uint32) (USBUART_LPM_STAT_REG & USBUART_LPM_STAT_LPM_BESL_MASK);
                  }
              
              
                  /***************************************************************************
                  * Function Name: USBUART_Lpm_RemoteWakeUpAllowed
                  ************************************************************************//**
                  *
                  *  This function returns the remote wakeup permission set for the device by
                  *  the host as part of the LPM token transaction.
                  *
                  * \return
                  *   0 - remote wakeup not allowed, 1 - remote wakeup allowed
                  *
                  *
                  ***************************************************************************/
                  uint32 USBUART_Lpm_RemoteWakeUpAllowed(void)
                  {
                      return (uint32) (USBUART_LPM_STAT_REG & USBUART_LPM_STAT_LPM_REMOTE_WAKE);
                  }
              
              
                  /***************************************************************************
                  * Function Name: USBUART_Lpm_SetResponse
                  ************************************************************************//**
                  *
                  *  This function configures the response in the handshake packet the device
                  *  has to send when an LPM token packet is received.
                  *
                  * \param response
                  *   type of response to return for an LPM token packet
                  *   Allowed response values:
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 47  

                  *       - USBUART_LPM_REQ_ACK - next LPM request will be
                  *                                           responded with ACK
                  *       - USBUART_LPM_REQ_NACK - next LPM request will be
                  *                                           responded with NACK
                  *       - USBUART_LPM_REQ_NYET - next LPM request will be
                  *                                           responded with NYET
                  *
                  ***************************************************************************/
                  void USBUART_Lpm_SetResponse(uint32 response)
                  {
                      uint32 lpmCtrl = USBUART_LPM_CTRL_REG & (uint32) ~USBUART_LPM_CTRL_ACK_NYET_MASK;
              
                      USBUART_LPM_CTRL_REG = lpmCtrl | ((uint32) response & USBUART_LPM_CTRL_ACK_NYET_MASK);
                  }
              
              
                  /***************************************************************************
                  * Function Name: USBUART_Lpm_GetResponse
                  ************************************************************************//**
                  *
                  *  This function returns the currently configured response value that the
                  *  device will send as part of the handshake packet when an LPM token
                  *  packet is received.
                  *
                  * \return
                  *   type of handshake response that will be returned by the device
                  *   for an LPM token packet
                  *   Possible response values:
                  *       - USBUART_LPM_REQ_ACK - next LPM request will be responded
                  *                                        with ACK
                  *       - USBUART_LPM_REQ_NACK - next LPM request will be responded
                  *                                        with NACK
                  *       - USBUART_LPM_REQ_NYET - next LPM request will be responded
                  *                                        with NYET
                  *
                  ***************************************************************************/
                  uint32 USBUART_Lpm_GetResponse(void)
                  {
              
                      return  ((uint32) USBUART_LPM_CTRL_REG & (uint32)USBUART_LPM_CTRL_ACK_NYET_MASK);
                  }
              
              
              #endif /* (USBUART_LPM_ACTIVE) */
2789          
2790          
2791          /* [] END OF FILE */
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 48  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _USBUART_Start (BEGIN)
                                           ; SOURCE LINE # 185
0000 900000      R     MOV     DPTR,#device
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#mode
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 186
                                           ; SOURCE LINE # 187
000A 900000      R     MOV     DPTR,#USBUART_initVar
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 188
                                           ; SOURCE LINE # 189
0012 120000      R     LCALL   USBUART_Init
                                           ; SOURCE LINE # 190
0015 900000      R     MOV     DPTR,#USBUART_initVar
0018 7401              MOV     A,#01H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 191
001B         ?C0001:
                                           ; SOURCE LINE # 193
001B 900000      R     MOV     DPTR,#device
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 900000      R     MOV     DPTR,#mode
0023 E0                MOVX    A,@DPTR
0024 FD                MOV     R5,A
0025 120000      R     LCALL   _USBUART_InitComponent
                                           ; SOURCE LINE # 194
0028 22                RET     
             ; FUNCTION _USBUART_Start (END)

             ; FUNCTION USBUART_Init (BEGIN)
                                           ; SOURCE LINE # 210
                                           ; SOURCE LINE # 211
                                           ; SOURCE LINE # 249
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 256
0008 9043A5            MOV     DPTR,#043A5H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 258
0013 9043B5            MOV     DPTR,#043B5H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4401              ORL     A,#01H
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 49  

001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 261
001E 90609D            MOV     DPTR,#0609DH
0021 7401              MOV     A,#01H
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 263
0024 906009            MOV     DPTR,#06009H
0027 7402              MOV     A,#02H
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 267
002A 906010            MOV     DPTR,#06010H
002D E0                MOVX    A,@DPTR
002E FF                MOV     R7,A
002F EF                MOV     A,R7
0030 547F              ANL     A,#07FH
0032 FF                MOV     R7,A
0033 EF                MOV     A,R7
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 268
0035 7F00              MOV     R7,#00H
0037 7E00              MOV     R6,#00H
0039 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 273
003C 904394            MOV     DPTR,#04394H
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 EF                MOV     A,R7
0042 54F9              ANL     A,#0F9H
0044 FF                MOV     R7,A
0045 EF                MOV     A,R7
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 277
0047 906012            MOV     DPTR,#06012H
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
004C EF                MOV     A,R7
004D 54DF              ANL     A,#0DFH
004F FF                MOV     R7,A
0050 EF                MOV     A,R7
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 280
0052 904394            MOV     DPTR,#04394H
0055 E0                MOVX    A,@DPTR
0056 FF                MOV     R7,A
0057 EF                MOV     A,R7
0058 4401              ORL     A,#01H
005A FF                MOV     R7,A
005B EF                MOV     A,R7
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 282
005D 7F01              MOV     R7,#01H
005F 7E00              MOV     R6,#00H
0061 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 284
0064 7F28              MOV     R7,#028H
0066 7E00              MOV     R6,#00H
0068 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 286
006B 9051F8            MOV     DPTR,#051F8H
006E E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 50  

006F FF                MOV     R7,A
0070 EF                MOV     A,R7
0071 547F              ANL     A,#07FH
0073 FF                MOV     R7,A
0074 EF                MOV     A,R7
0075 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 287
0076 9051F8            MOV     DPTR,#051F8H
0079 E0                MOVX    A,@DPTR
007A FF                MOV     R7,A
007B EF                MOV     A,R7
007C 54BF              ANL     A,#0BFH
007E FF                MOV     R7,A
007F EF                MOV     A,R7
0080 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 290
0081 904394            MOV     DPTR,#04394H
0084 E0                MOVX    A,@DPTR
0085 FF                MOV     R7,A
0086 EF                MOV     A,R7
0087 4402              ORL     A,#02H
0089 FF                MOV     R7,A
008A EF                MOV     A,R7
008B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 291
008C 7F02              MOV     R7,#02H
008E 7E00              MOV     R6,#00H
0090 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 293
0093 904394            MOV     DPTR,#04394H
0096 E0                MOVX    A,@DPTR
0097 FF                MOV     R7,A
0098 EF                MOV     A,R7
0099 4404              ORL     A,#04H
009B FF                MOV     R7,A
009C EF                MOV     A,R7
009D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 296
009E 906084            MOV     DPTR,#06084H
00A1 E4                CLR     A
00A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 297
00A3 906085            MOV     DPTR,#06085H
00A6 E4                CLR     A
00A7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 311
00A8 900000      R     MOV     DPTR,#enableInterrupts
00AB E0                MOVX    A,@DPTR
00AC FF                MOV     R7,A
00AD 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 330
00B0 7D07              MOV     R5,#07H
00B2 7F17              MOV     R7,#017H
00B4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 331
00B7 7C00        E     MOV     R4,#HIGH USBUART_BUS_RESET_ISR
00B9 7D00        E     MOV     R5,#LOW USBUART_BUS_RESET_ISR
00BB 7F17              MOV     R7,#017H
00BD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 334
00C0 7D07              MOV     R5,#07H
00C2 7F18              MOV     R7,#018H
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 51  

00C4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 335
00C7 7C00        E     MOV     R4,#HIGH USBUART_EP_0_ISR
00C9 7D00        E     MOV     R5,#LOW USBUART_EP_0_ISR
00CB 7F18              MOV     R7,#018H
00CD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 339
00D0 7D07              MOV     R5,#07H
00D2 7F15              MOV     R7,#015H
00D4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 340
00D7 7C00        E     MOV     R4,#HIGH USBUART_SOF_ISR
00D9 7D00        E     MOV     R5,#LOW USBUART_SOF_ISR
00DB 7F15              MOV     R7,#015H
00DD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 345
00E0 7D07              MOV     R5,#07H
00E2 7F00              MOV     R7,#00H
00E4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 346
00E7 7C00        E     MOV     R4,#HIGH USBUART_EP_1_ISR
00E9 7D00        E     MOV     R5,#LOW USBUART_EP_1_ISR
00EB 7F00              MOV     R7,#00H
00ED 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 351
00F0 7D07              MOV     R5,#07H
00F2 7F01              MOV     R7,#01H
00F4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 352
00F7 7C00        E     MOV     R4,#HIGH USBUART_EP_2_ISR
00F9 7D00        E     MOV     R5,#LOW USBUART_EP_2_ISR
00FB 7F01              MOV     R7,#01H
00FD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 357
0100 7D07              MOV     R5,#07H
0102 7F02              MOV     R7,#02H
0104 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 358
0107 7C00        E     MOV     R4,#HIGH USBUART_EP_3_ISR
0109 7D00        E     MOV     R5,#LOW USBUART_EP_3_ISR
010B 7F02              MOV     R7,#02H
010D 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 400
0110 7D07              MOV     R5,#07H
0112 7F0C              MOV     R7,#0CH
0114 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 401
0117 7C00        E     MOV     R4,#HIGH USBUART_DP_ISR
0119 7D00        E     MOV     R5,#LOW USBUART_DP_ISR
011B 7F0C              MOV     R7,#0CH
011D 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 408
0120 22                RET     
             ; FUNCTION USBUART_Init (END)

             ; FUNCTION _USBUART_InitComponent (BEGIN)
                                           ; SOURCE LINE # 459
0000 900000      R     MOV     DPTR,#device
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#mode
0008 ED                MOV     A,R5
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 52  

0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 460
                                           ; SOURCE LINE # 468
000A 900000      R     MOV     DPTR,#i
000D E4                CLR     A
000E F0                MOVX    @DPTR,A
000F         ?C0004:
000F 900000      R     MOV     DPTR,#i
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 EF                MOV     A,R7
0015 C3                CLR     C
0016 9402              SUBB    A,#02H
0018 501A              JNC     ?C0005
                                           ; SOURCE LINE # 469
                                           ; SOURCE LINE # 470
001A 900000      R     MOV     DPTR,#i
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F 7400        E     MOV     A,#LOW USBUART_hidProtocol
0021 2F                ADD     A,R7
0022 F582              MOV     DPL,A
0024 E4                CLR     A
0025 3400        E     ADDC    A,#HIGH USBUART_hidProtocol
0027 F583              MOV     DPH,A
0029 7401              MOV     A,#01H
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 471
002C 900000      R     MOV     DPTR,#i
002F E0                MOVX    A,@DPTR
0030 04                INC     A
0031 F0                MOVX    @DPTR,A
0032 80DB              SJMP    ?C0004
0034         ?C0005:
                                           ; SOURCE LINE # 475
0034 900000      R     MOV     DPTR,#device
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 900000      E     MOV     DPTR,#USBUART_device
003C EF                MOV     A,R7
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 478
003E 900000      E     MOV     DPTR,#USBUART_transferState
0041 E4                CLR     A
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 479
0043 900000      E     MOV     DPTR,#USBUART_configurationChanged
0046 E4                CLR     A
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 480
0048 900000      E     MOV     DPTR,#USBUART_configuration
004B E4                CLR     A
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 481
004D 900000      E     MOV     DPTR,#USBUART_interfaceNumber
0050 E4                CLR     A
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 482
0052 900000      E     MOV     DPTR,#USBUART_deviceAddress
0055 E4                CLR     A
0056 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 483
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 53  

0057 900000      E     MOV     DPTR,#USBUART_deviceStatus
005A E4                CLR     A
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 484
005C 900000      E     MOV     DPTR,#USBUART_lastPacketSize
005F E4                CLR     A
0060 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 492
0061 9044C2            MOV     DPTR,#044C2H
0064 7480              MOV     A,#080H
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 493
0067 9044C3            MOV     DPTR,#044C3H
006A 7401              MOV     A,#01H
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 496
006D 9044C2            MOV     DPTR,#044C2H
0070 7420              MOV     A,#020H
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 500
0073 9044C0            MOV     DPTR,#044C0H
0076 7401              MOV     A,#01H
0078 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 504
0079 9044C0            MOV     DPTR,#044C0H
007C 7402              MOV     A,#02H
007E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 508
007F 9044C0            MOV     DPTR,#044C0H
0082 7404              MOV     A,#04H
0084 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 572
0085 900000      R     MOV     DPTR,#mode
0088 E0                MOVX    A,@DPTR
0089 FF                MOV     R7,A
008A EF                MOV     A,R7
008B 120000      E     LCALL   ?C?CCASE
008E 0000        R     DW      ?C0008
0090 00                DB      00H
0091 0000        R     DW      ?C0009
0093 01                DB      01H
0094 0000              DW      00H
0096 0000        R     DW      ?C0010
                                           ; SOURCE LINE # 573
                                           ; SOURCE LINE # 574
0098         ?C0008:
                                           ; SOURCE LINE # 576
0098 906009            MOV     DPTR,#06009H
009B E0                MOVX    A,@DPTR
009C FF                MOV     R7,A
009D EF                MOV     A,R7
009E 54FE              ANL     A,#0FEH
00A0 FF                MOV     R7,A
00A1 EF                MOV     A,R7
00A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 577
00A3 8018              SJMP    ?C0007
                                           ; SOURCE LINE # 579
00A5         ?C0009:
                                           ; SOURCE LINE # 581
00A5 906009            MOV     DPTR,#06009H
00A8 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 54  

00A9 FF                MOV     R7,A
00AA EF                MOV     A,R7
00AB 4401              ORL     A,#01H
00AD FF                MOV     R7,A
00AE EF                MOV     A,R7
00AF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 582
00B0 800B              SJMP    ?C0007
                                           ; SOURCE LINE # 584
00B2         ?C0010:
                                           ; SOURCE LINE # 590
00B2 906009            MOV     DPTR,#06009H
00B5 E0                MOVX    A,@DPTR
00B6 FF                MOV     R7,A
00B7 EF                MOV     A,R7
00B8 4401              ORL     A,#01H
00BA FF                MOV     R7,A
00BB EF                MOV     A,R7
00BC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 592
                                           ; SOURCE LINE # 593
00BD         ?C0007:
                                           ; SOURCE LINE # 626
00BD 906028            MOV     DPTR,#06028H
00C0 7403              MOV     A,#03H
00C2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 629
00C3 906008            MOV     DPTR,#06008H
00C6 7480              MOV     A,#080H
00C8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 630
00C9 7F01              MOV     R7,#01H
00CB 7E00              MOV     R6,#00H
00CD 7D00              MOV     R5,#00H
00CF 7C00              MOV     R4,#00H
00D1 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 634
00D4 906012            MOV     DPTR,#06012H
00D7 7404              MOV     A,#04H
00D9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 635
00DA 22                RET     
             ; FUNCTION _USBUART_InitComponent (END)

             ; FUNCTION USBUART_ReInitComponent (BEGIN)
                                           ; SOURCE LINE # 670
                                           ; SOURCE LINE # 671
                                           ; SOURCE LINE # 678
0000 900000      R     MOV     DPTR,#i
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
0005         ?C0012:
0005 900000      R     MOV     DPTR,#i
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B C3                CLR     C
000C 9402              SUBB    A,#02H
000E 501A              JNC     ?C0013
                                           ; SOURCE LINE # 679
                                           ; SOURCE LINE # 680
0010 900000      R     MOV     DPTR,#i
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 55  

0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 7400        E     MOV     A,#LOW USBUART_hidProtocol
0017 2F                ADD     A,R7
0018 F582              MOV     DPL,A
001A E4                CLR     A
001B 3400        E     ADDC    A,#HIGH USBUART_hidProtocol
001D F583              MOV     DPH,A
001F 7401              MOV     A,#01H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 681
0022 900000      R     MOV     DPTR,#i
0025 E0                MOVX    A,@DPTR
0026 04                INC     A
0027 F0                MOVX    @DPTR,A
0028 80DB              SJMP    ?C0012
002A         ?C0013:
                                           ; SOURCE LINE # 685
002A 900000      E     MOV     DPTR,#USBUART_transferState
002D E4                CLR     A
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 686
002F 900000      E     MOV     DPTR,#USBUART_configurationChanged
0032 E4                CLR     A
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 687
0034 900000      E     MOV     DPTR,#USBUART_configuration
0037 E4                CLR     A
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 688
0039 900000      E     MOV     DPTR,#USBUART_interfaceNumber
003C E4                CLR     A
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 689
003E 900000      E     MOV     DPTR,#USBUART_deviceAddress
0041 E4                CLR     A
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 690
0043 900000      E     MOV     DPTR,#USBUART_deviceStatus
0046 E4                CLR     A
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 691
0048 900000      E     MOV     DPTR,#USBUART_lastPacketSize
004B E4                CLR     A
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 698
004D 906028            MOV     DPTR,#06028H
0050 7403              MOV     A,#03H
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 702
0053 906008            MOV     DPTR,#06008H
0056 7480              MOV     A,#080H
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 703
0059 22                RET     
             ; FUNCTION USBUART_ReInitComponent (END)

             ; FUNCTION USBUART_Stop (BEGIN)
                                           ; SOURCE LINE # 728
                                           ; SOURCE LINE # 729
                                           ; SOURCE LINE # 737
0000 120000      E     LCALL   CyEnterCriticalSection
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 56  

0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 740
0008 906008            MOV     DPTR,#06008H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 547F              ANL     A,#07FH
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 743
0013 906012            MOV     DPTR,#06012H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FB              ANL     A,#0FBH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 750
001E 9043A5            MOV     DPTR,#043A5H
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 54FE              ANL     A,#0FEH
0026 FF                MOV     R7,A
0027 EF                MOV     A,R7
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 751
0029 9043B5            MOV     DPTR,#043B5H
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E EF                MOV     A,R7
002F 54FE              ANL     A,#0FEH
0031 FF                MOV     R7,A
0032 EF                MOV     A,R7
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 754
0034 900000      R     MOV     DPTR,#enableInterrupts
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 763
003C 9044CA            MOV     DPTR,#044CAH
003F 7480              MOV     A,#080H
0041 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 764
0042 9044CB            MOV     DPTR,#044CBH
0045 7401              MOV     A,#01H
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 767
0048 9044CA            MOV     DPTR,#044CAH
004B 7420              MOV     A,#020H
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 771
004E 9044C8            MOV     DPTR,#044C8H
0051 7401              MOV     A,#01H
0053 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 775
0054 9044C8            MOV     DPTR,#044C8H
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 57  

0057 7402              MOV     A,#02H
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 779
005A 9044C8            MOV     DPTR,#044C8H
005D 7404              MOV     A,#04H
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 804
0060 900000      E     MOV     DPTR,#USBUART_configurationChanged
0063 E4                CLR     A
0064 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 805
0065 900000      E     MOV     DPTR,#USBUART_configuration
0068 E4                CLR     A
0069 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 806
006A 900000      E     MOV     DPTR,#USBUART_interfaceNumber
006D E4                CLR     A
006E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 807
006F 900000      E     MOV     DPTR,#USBUART_deviceAddress
0072 E4                CLR     A
0073 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 808
0074 900000      E     MOV     DPTR,#USBUART_deviceStatus
0077 E4                CLR     A
0078 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 811
0079 900000      R     MOV     DPTR,#USBUART_initVar
007C E4                CLR     A
007D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 812
007E 22                RET     
             ; FUNCTION USBUART_Stop (END)

             ; FUNCTION USBUART_CheckActivity (BEGIN)
                                           ; SOURCE LINE # 835
                                           ; SOURCE LINE # 836
                                           ; SOURCE LINE # 837
0000 906009            MOV     DPTR,#06009H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#cr1Reg
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 840
000A 900000      R     MOV     DPTR,#cr1Reg
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 54FB              ANL     A,#0FBH
0012 FF                MOV     R7,A
0013 906009            MOV     DPTR,#06009H
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 843
0018 900000      R     MOV     DPTR,#cr1Reg
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 30E204            JNB     ACC.2,?C0017
0021 7F01              MOV     R7,#01H
0023 8002              SJMP    ?C0018
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 58  

0025         ?C0017:
0025 7F00              MOV     R7,#00H
0027         ?C0018:
                                           ; SOURCE LINE # 844
0027         ?C0019:
0027 22                RET     
             ; FUNCTION USBUART_CheckActivity (END)

             ; FUNCTION USBUART_GetConfiguration (BEGIN)
                                           ; SOURCE LINE # 858
                                           ; SOURCE LINE # 859
                                           ; SOURCE LINE # 860
0000 900000      E     MOV     DPTR,#USBUART_configuration
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 861
0005         ?C0020:
0005 22                RET     
             ; FUNCTION USBUART_GetConfiguration (END)

             ; FUNCTION USBUART_IsConfigurationChanged (BEGIN)
                                           ; SOURCE LINE # 884
                                           ; SOURCE LINE # 885
                                           ; SOURCE LINE # 886
0000 900000      R     MOV     DPTR,#res
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 888
0005 900000      E     MOV     DPTR,#USBUART_configurationChanged
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600F              JZ      ?C0021
                                           ; SOURCE LINE # 889
                                           ; SOURCE LINE # 890
000D 900000      E     MOV     DPTR,#USBUART_configurationChanged
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 900000      R     MOV     DPTR,#res
0015 EF                MOV     A,R7
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 891
0017 900000      E     MOV     DPTR,#USBUART_configurationChanged
001A E4                CLR     A
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 892
001C         ?C0021:
                                           ; SOURCE LINE # 894
001C 900000      R     MOV     DPTR,#res
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
                                           ; SOURCE LINE # 895
0021         ?C0022:
0021 22                RET     
             ; FUNCTION USBUART_IsConfigurationChanged (END)

             ; FUNCTION _USBUART_GetInterfaceSetting (BEGIN)
                                           ; SOURCE LINE # 913
0000 900000      R     MOV     DPTR,#interfaceNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 915
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 59  

                                           ; SOURCE LINE # 916
0005 900000      R     MOV     DPTR,#interfaceNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 7400        E     MOV     A,#LOW USBUART_interfaceSetting
000C 2F                ADD     A,R7
000D F582              MOV     DPL,A
000F E4                CLR     A
0010 3400        E     ADDC    A,#HIGH USBUART_interfaceSetting
0012 F583              MOV     DPH,A
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
                                           ; SOURCE LINE # 917
0016         ?C0023:
0016 22                RET     
             ; FUNCTION _USBUART_GetInterfaceSetting (END)

             ; FUNCTION _USBUART_GetEPState (BEGIN)
                                           ; SOURCE LINE # 945
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 946
                                           ; SOURCE LINE # 947
0005 900000      R     MOV     DPTR,#epNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 75F00B            MOV     B,#0BH
000E A4                MUL     AB
000F 2400        E     ADD     A,#LOW USBUART_EP+01H
0011 F582              MOV     DPL,A
0013 E4                CLR     A
0014 3400        E     ADDC    A,#HIGH USBUART_EP+01H
0016 F583              MOV     DPH,A
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
                                           ; SOURCE LINE # 948
001A         ?C0024:
001A 22                RET     
             ; FUNCTION _USBUART_GetEPState (END)

             ; FUNCTION _USBUART_GetEPCount (BEGIN)
                                           ; SOURCE LINE # 968
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 969
                                           ; SOURCE LINE # 970
0005 900000      R     MOV     DPTR,#cntr
0008 E4                CLR     A
0009 F0                MOVX    @DPTR,A
000A A3                INC     DPTR
000B E4                CLR     A
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 972
000D 900000      R     MOV     DPTR,#epNumber
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 D3                SETB    C
0014 9400              SUBB    A,#00H
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 60  

0016 4066              JC      ?C0025
0018 900000      R     MOV     DPTR,#epNumber
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E C3                CLR     C
001F 9409              SUBB    A,#09H
0021 505B              JNC     ?C0025
                                           ; SOURCE LINE # 973
                                           ; SOURCE LINE # 975
0023 900000      R     MOV     DPTR,#epNumber
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 75F010            MOV     B,#010H
002B EF                MOV     A,R7
002C 905FFC            MOV     DPTR,#05FFCH
002F 120000      E     LCALL   ?C?OFFXADD
0032 E0                MOVX    A,@DPTR
0033 FF                MOV     R7,A
0034 7E00              MOV     R6,#00H
0036 7E00              MOV     R6,#00H
0038 EF                MOV     A,R7
0039 540F              ANL     A,#0FH
003B FF                MOV     R7,A
003C 900000      R     MOV     DPTR,#cntr
003F EE                MOV     A,R6
0040 F0                MOVX    @DPTR,A
0041 A3                INC     DPTR
0042 EF                MOV     A,R7
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 976
0044 900000      R     MOV     DPTR,#epNumber
0047 E0                MOVX    A,@DPTR
0048 FF                MOV     R7,A
0049 75F010            MOV     B,#010H
004C EF                MOV     A,R7
004D 905FFD            MOV     DPTR,#05FFDH
0050 120000      E     LCALL   ?C?OFFXADD
0053 E0                MOVX    A,@DPTR
0054 FF                MOV     R7,A
0055 EF                MOV     A,R7
0056 FD                MOV     R5,A
0057 7C00              MOV     R4,#00H
0059 900000      R     MOV     DPTR,#cntr
005C E0                MOVX    A,@DPTR
005D FE                MOV     R6,A
005E A3                INC     DPTR
005F E0                MOVX    A,@DPTR
0060 FF                MOV     R7,A
0061 EF                MOV     A,R7
0062 7F00              MOV     R7,#00H
0064 FE                MOV     R6,A
0065 EE                MOV     A,R6
0066 4C                ORL     A,R4
0067 FE                MOV     R6,A
0068 EF                MOV     A,R7
0069 4D                ORL     A,R5
006A FF                MOV     R7,A
006B 900000      R     MOV     DPTR,#cntr
006E EE                MOV     A,R6
006F F0                MOVX    @DPTR,A
0070 A3                INC     DPTR
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 61  

0071 EF                MOV     A,R7
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 977
0073 900000      R     MOV     DPTR,#cntr
0076 74FF              MOV     A,#0FFH
0078 75F0FE            MOV     B,#0FEH
007B 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 978
007E         ?C0025:
                                           ; SOURCE LINE # 980
007E 900000      R     MOV     DPTR,#cntr
0081 E0                MOVX    A,@DPTR
0082 FE                MOV     R6,A
0083 A3                INC     DPTR
0084 E0                MOVX    A,@DPTR
0085 FF                MOV     R7,A
                                           ; SOURCE LINE # 981
0086         ?C0026:
0086 22                RET     
             ; FUNCTION _USBUART_GetEPCount (END)

             ; FUNCTION _USBUART_LoadInEP (BEGIN)
                                           ; SOURCE LINE # 1328
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#pData
0008 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1330
                                           ; SOURCE LINE # 1331
000B 900000      R     MOV     DPTR,#epNumber
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 D3                SETB    C
0012 9400              SUBB    A,#00H
0014 5003              JNC     $ + 5H
0016 020000      R     LJMP    ?C0033
0019 900000      R     MOV     DPTR,#epNumber
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E EF                MOV     A,R7
001F C3                CLR     C
0020 9409              SUBB    A,#09H
0022 4003              JC      $ + 5H
0024 020000      R     LJMP    ?C0033
                                           ; SOURCE LINE # 1332
                                           ; SOURCE LINE # 1335
0027 900000      R     MOV     DPTR,#epNumber
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D 75F00B            MOV     B,#0BH
0030 A4                MUL     AB
0031 2400        E     ADD     A,#LOW USBUART_EP+06H
0033 F582              MOV     DPL,A
0035 E4                CLR     A
0036 3400        E     ADDC    A,#HIGH USBUART_EP+06H
0038 F583              MOV     DPH,A
003A E0                MOVX    A,@DPTR
003B FE                MOV     R6,A
003C A3                INC     DPTR
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 62  

003D E0                MOVX    A,@DPTR
003E FF                MOV     R7,A
003F C3                CLR     C
0040 E4                CLR     A
0041 9F                SUBB    A,R7
0042 FF                MOV     R7,A
0043 7402              MOV     A,#02H
0045 9E                SUBB    A,R6
0046 FE                MOV     R6,A
0047 900000      R     MOV     DPTR,#length
004A E0                MOVX    A,@DPTR
004B FC                MOV     R4,A
004C A3                INC     DPTR
004D E0                MOVX    A,@DPTR
004E FD                MOV     R5,A
004F D3                SETB    C
0050 ED                MOV     A,R5
0051 9F                SUBB    A,R7
0052 EC                MOV     A,R4
0053 9E                SUBB    A,R6
0054 4028              JC      ?C0028
                                           ; SOURCE LINE # 1336
                                           ; SOURCE LINE # 1337
0056 900000      R     MOV     DPTR,#epNumber
0059 E0                MOVX    A,@DPTR
005A FF                MOV     R7,A
005B EF                MOV     A,R7
005C 75F00B            MOV     B,#0BH
005F A4                MUL     AB
0060 2400        E     ADD     A,#LOW USBUART_EP+06H
0062 F582              MOV     DPL,A
0064 E4                CLR     A
0065 3400        E     ADDC    A,#HIGH USBUART_EP+06H
0067 F583              MOV     DPH,A
0069 E0                MOVX    A,@DPTR
006A FE                MOV     R6,A
006B A3                INC     DPTR
006C E0                MOVX    A,@DPTR
006D FF                MOV     R7,A
006E C3                CLR     C
006F E4                CLR     A
0070 9F                SUBB    A,R7
0071 FF                MOV     R7,A
0072 7402              MOV     A,#02H
0074 9E                SUBB    A,R6
0075 FE                MOV     R6,A
0076 900000      R     MOV     DPTR,#length
0079 EE                MOV     A,R6
007A F0                MOVX    @DPTR,A
007B A3                INC     DPTR
007C EF                MOV     A,R7
007D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1338
007E         ?C0028:
                                           ; SOURCE LINE # 1342
007E 900000      R     MOV     DPTR,#length
0081 E0                MOVX    A,@DPTR
0082 FE                MOV     R6,A
0083 A3                INC     DPTR
0084 E0                MOVX    A,@DPTR
0085 FF                MOV     R7,A
0086 EE                MOV     A,R6
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 63  

0087 FF                MOV     R7,A
0088 7E00              MOV     R6,#00H
008A 900000      R     MOV     DPTR,#epNumber
008D E0                MOVX    A,@DPTR
008E FE                MOV     R6,A
008F EE                MOV     A,R6
0090 75F00B            MOV     B,#0BH
0093 A4                MUL     AB
0094 2400        E     ADD     A,#LOW USBUART_EP+03H
0096 F582              MOV     DPL,A
0098 E4                CLR     A
0099 3400        E     ADDC    A,#HIGH USBUART_EP+03H
009B F583              MOV     DPH,A
009D E0                MOVX    A,@DPTR
009E FE                MOV     R6,A
009F EF                MOV     A,R7
00A0 4E                ORL     A,R6
00A1 FF                MOV     R7,A
00A2 900000      R     MOV     DPTR,#epNumber
00A5 E0                MOVX    A,@DPTR
00A6 FE                MOV     R6,A
00A7 75F010            MOV     B,#010H
00AA EE                MOV     A,R6
00AB 905FFC            MOV     DPTR,#05FFCH
00AE 120000      E     LCALL   ?C?OFFXADD
00B1 EF                MOV     A,R7
00B2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1343
00B3 900000      R     MOV     DPTR,#length
00B6 E0                MOVX    A,@DPTR
00B7 FE                MOV     R6,A
00B8 A3                INC     DPTR
00B9 E0                MOVX    A,@DPTR
00BA FF                MOV     R7,A
00BB EF                MOV     A,R7
00BC 54FF              ANL     A,#0FFH
00BE FF                MOV     R7,A
00BF 900000      R     MOV     DPTR,#epNumber
00C2 E0                MOVX    A,@DPTR
00C3 FE                MOV     R6,A
00C4 75F010            MOV     B,#010H
00C7 EE                MOV     A,R6
00C8 905FFD            MOV     DPTR,#05FFDH
00CB 120000      E     LCALL   ?C?OFFXADD
00CE EF                MOV     A,R7
00CF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1346
00D0 7B00              MOV     R3,#00H
00D2 7A00              MOV     R2,#00H
00D4 7900              MOV     R1,#00H
00D6 C003              PUSH    AR3
00D8 C002              PUSH    AR2
00DA C001              PUSH    AR1
00DC 900000      R     MOV     DPTR,#pData
00DF 120000      E     LCALL   ?C?PLDXDATA
00E2 D082              POP     DPL
00E4 D083              POP     DPH
00E6 D0E0              POP     ACC
00E8 6B                XRL     A,R3
00E9 7008              JNZ     ?C0057
00EB E9                MOV     A,R1
00EC 6582              XRL     A,DPL
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 64  

00EE 7003              JNZ     ?C0057
00F0 EA                MOV     A,R2
00F1 6583              XRL     A,DPH
00F3         ?C0057:
00F3 6054              JZ      ?C0029
                                           ; SOURCE LINE # 1347
                                           ; SOURCE LINE # 1350
00F5 900000      R     MOV     DPTR,#i
00F8 E4                CLR     A
00F9 F0                MOVX    @DPTR,A
00FA A3                INC     DPTR
00FB E4                CLR     A
00FC F0                MOVX    @DPTR,A
00FD         ?C0030:
00FD 900000      R     MOV     DPTR,#length
0100 E0                MOVX    A,@DPTR
0101 FE                MOV     R6,A
0102 A3                INC     DPTR
0103 E0                MOVX    A,@DPTR
0104 FF                MOV     R7,A
0105 900000      R     MOV     DPTR,#i
0108 E0                MOVX    A,@DPTR
0109 FC                MOV     R4,A
010A A3                INC     DPTR
010B E0                MOVX    A,@DPTR
010C FD                MOV     R5,A
010D C3                CLR     C
010E ED                MOV     A,R5
010F 9F                SUBB    A,R7
0110 EC                MOV     A,R4
0111 9E                SUBB    A,R6
0112 5035              JNC     ?C0029
                                           ; SOURCE LINE # 1351
                                           ; SOURCE LINE # 1352
0114 900000      R     MOV     DPTR,#pData
0117 120000      E     LCALL   ?C?PLDXDATA
011A 900000      R     MOV     DPTR,#i
011D E0                MOVX    A,@DPTR
011E FE                MOV     R6,A
011F A3                INC     DPTR
0120 E0                MOVX    A,@DPTR
0121 FF                MOV     R7,A
0122 E9                MOV     A,R1
0123 2F                ADD     A,R7
0124 F9                MOV     R1,A
0125 EA                MOV     A,R2
0126 3E                ADDC    A,R6
0127 FA                MOV     R2,A
0128 120000      E     LCALL   ?C?CLDPTR
012B FF                MOV     R7,A
012C 900000      R     MOV     DPTR,#epNumber
012F E0                MOVX    A,@DPTR
0130 FE                MOV     R6,A
0131 75F010            MOV     B,#010H
0134 EE                MOV     A,R6
0135 906078            MOV     DPTR,#06078H
0138 120000      E     LCALL   ?C?OFFXADD
013B EF                MOV     A,R7
013C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1353
013D 900000      R     MOV     DPTR,#i
0140 E4                CLR     A
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 65  

0141 75F001            MOV     B,#01H
0144 120000      E     LCALL   ?C?IILDX
0147 80B4              SJMP    ?C0030
                                           ; SOURCE LINE # 1354
0149         ?C0029:
                                           ; SOURCE LINE # 1357
0149 900000      R     MOV     DPTR,#epNumber
014C E0                MOVX    A,@DPTR
014D FF                MOV     R7,A
014E EF                MOV     A,R7
014F 75F00B            MOV     B,#0BH
0152 A4                MUL     AB
0153 2400        E     ADD     A,#LOW USBUART_EP+01H
0155 F582              MOV     DPL,A
0157 E4                CLR     A
0158 3400        E     ADDC    A,#HIGH USBUART_EP+01H
015A F583              MOV     DPH,A
015C E4                CLR     A
015D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1360
015E 900000      R     MOV     DPTR,#epNumber
0161 E0                MOVX    A,@DPTR
0162 FF                MOV     R7,A
0163 EF                MOV     A,R7
0164 75F00B            MOV     B,#0BH
0167 A4                MUL     AB
0168 2400        E     ADD     A,#LOW USBUART_EP+05H
016A F582              MOV     DPL,A
016C E4                CLR     A
016D 3400        E     ADDC    A,#HIGH USBUART_EP+05H
016F F583              MOV     DPH,A
0171 E0                MOVX    A,@DPTR
0172 FF                MOV     R7,A
0173 900000      R     MOV     DPTR,#epNumber
0176 E0                MOVX    A,@DPTR
0177 FE                MOV     R6,A
0178 75F010            MOV     B,#010H
017B EE                MOV     A,R6
017C 905FFE            MOV     DPTR,#05FFEH
017F 120000      E     LCALL   ?C?OFFXADD
0182 EF                MOV     A,R7
0183 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1585
                                           ; SOURCE LINE # 1586
0184         ?C0033:
0184 22                RET     
             ; FUNCTION _USBUART_LoadInEP (END)

             ; FUNCTION _USBUART_ReadOutEP (BEGIN)
                                           ; SOURCE LINE # 1635
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#pData
0008 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1637
                                           ; SOURCE LINE # 1638
000B 7B00              MOV     R3,#00H
000D 7A00              MOV     R2,#00H
000F 7900              MOV     R1,#00H
0011 C003              PUSH    AR3
0013 C002              PUSH    AR2
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 66  

0015 C001              PUSH    AR1
0017 900000      R     MOV     DPTR,#pData
001A 120000      E     LCALL   ?C?PLDXDATA
001D D082              POP     DPL
001F D083              POP     DPH
0021 D0E0              POP     ACC
0023 6B                XRL     A,R3
0024 7008              JNZ     ?C0058
0026 E9                MOV     A,R1
0027 6582              XRL     A,DPL
0029 7003              JNZ     ?C0058
002B EA                MOV     A,R2
002C 6583              XRL     A,DPH
002E         ?C0058:
002E 7003              JNZ     $ + 5H
0030 020000      R     LJMP    ?C0034
0033 900000      R     MOV     DPTR,#epNumber
0036 E0                MOVX    A,@DPTR
0037 FF                MOV     R7,A
0038 EF                MOV     A,R7
0039 D3                SETB    C
003A 9400              SUBB    A,#00H
003C 5003              JNC     $ + 5H
003E 020000      R     LJMP    ?C0034
0041 900000      R     MOV     DPTR,#epNumber
0044 E0                MOVX    A,@DPTR
0045 FF                MOV     R7,A
0046 EF                MOV     A,R7
0047 C3                CLR     C
0048 9409              SUBB    A,#09H
004A 4003              JC      $ + 5H
004C 020000      R     LJMP    ?C0034
                                           ; SOURCE LINE # 1639
                                           ; SOURCE LINE # 1642
004F 900000      R     MOV     DPTR,#epNumber
0052 E0                MOVX    A,@DPTR
0053 FF                MOV     R7,A
0054 120000      R     LCALL   _USBUART_GetEPCount
0057 900000      R     MOV     DPTR,#length
005A E0                MOVX    A,@DPTR
005B FC                MOV     R4,A
005C A3                INC     DPTR
005D E0                MOVX    A,@DPTR
005E FD                MOV     R5,A
005F D3                SETB    C
0060 ED                MOV     A,R5
0061 9F                SUBB    A,R7
0062 EC                MOV     A,R4
0063 9E                SUBB    A,R6
0064 400A              JC      ?C0035
0066 900000      R     MOV     DPTR,#epNumber
0069 E0                MOVX    A,@DPTR
006A FF                MOV     R7,A
006B 120000      R     LCALL   _USBUART_GetEPCount
006E 8008              SJMP    ?C0036
0070         ?C0035:
0070 900000      R     MOV     DPTR,#length
0073 E0                MOVX    A,@DPTR
0074 FE                MOV     R6,A
0075 A3                INC     DPTR
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 67  

0078         ?C0036:
0078 900000      R     MOV     DPTR,#length
007B EE                MOV     A,R6
007C F0                MOVX    @DPTR,A
007D A3                INC     DPTR
007E EF                MOV     A,R7
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1646
                                           ; SOURCE LINE # 1649
0080 900000      R     MOV     DPTR,#i
0083 E4                CLR     A
0084 F0                MOVX    @DPTR,A
0085 A3                INC     DPTR
0086 E4                CLR     A
0087 F0                MOVX    @DPTR,A
0088         ?C0037:
0088 900000      R     MOV     DPTR,#length
008B E0                MOVX    A,@DPTR
008C FE                MOV     R6,A
008D A3                INC     DPTR
008E E0                MOVX    A,@DPTR
008F FF                MOV     R7,A
0090 900000      R     MOV     DPTR,#i
0093 E0                MOVX    A,@DPTR
0094 FC                MOV     R4,A
0095 A3                INC     DPTR
0096 E0                MOVX    A,@DPTR
0097 FD                MOV     R5,A
0098 C3                CLR     C
0099 ED                MOV     A,R5
009A 9F                SUBB    A,R7
009B EC                MOV     A,R4
009C 9E                SUBB    A,R6
009D 5035              JNC     ?C0038
                                           ; SOURCE LINE # 1650
                                           ; SOURCE LINE # 1651
009F 900000      R     MOV     DPTR,#epNumber
00A2 E0                MOVX    A,@DPTR
00A3 FF                MOV     R7,A
00A4 75F010            MOV     B,#010H
00A7 EF                MOV     A,R7
00A8 906078            MOV     DPTR,#06078H
00AB 120000      E     LCALL   ?C?OFFXADD
00AE E0                MOVX    A,@DPTR
00AF FF                MOV     R7,A
00B0 900000      R     MOV     DPTR,#pData
00B3 120000      E     LCALL   ?C?PLDXDATA
00B6 900000      R     MOV     DPTR,#i
00B9 E0                MOVX    A,@DPTR
00BA FC                MOV     R4,A
00BB A3                INC     DPTR
00BC E0                MOVX    A,@DPTR
00BD FD                MOV     R5,A
00BE E9                MOV     A,R1
00BF 2D                ADD     A,R5
00C0 F9                MOV     R1,A
00C1 EA                MOV     A,R2
00C2 3C                ADDC    A,R4
00C3 FA                MOV     R2,A
00C4 EF                MOV     A,R7
00C5 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 1652
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 68  

00C8 900000      R     MOV     DPTR,#i
00CB E4                CLR     A
00CC 75F001            MOV     B,#01H
00CF 120000      E     LCALL   ?C?IILDX
00D2 80B4              SJMP    ?C0037
00D4         ?C0038:
                                           ; SOURCE LINE # 1653
                                           ; SOURCE LINE # 1656
00D4 900000      R     MOV     DPTR,#epNumber
00D7 E0                MOVX    A,@DPTR
00D8 FF                MOV     R7,A
00D9 120000      R     LCALL   _USBUART_EnableOutEP
                                           ; SOURCE LINE # 1795
00DC 8008              SJMP    ?C0040
00DE         ?C0034:
                                           ; SOURCE LINE # 1797
                                           ; SOURCE LINE # 1798
00DE 900000      R     MOV     DPTR,#length
00E1 E4                CLR     A
00E2 F0                MOVX    @DPTR,A
00E3 A3                INC     DPTR
00E4 E4                CLR     A
00E5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1799
00E6         ?C0040:
                                           ; SOURCE LINE # 1801
00E6 900000      R     MOV     DPTR,#length
00E9 E0                MOVX    A,@DPTR
00EA FE                MOV     R6,A
00EB A3                INC     DPTR
00EC E0                MOVX    A,@DPTR
00ED FF                MOV     R7,A
                                           ; SOURCE LINE # 1802
00EE         ?C0041:
00EE 22                RET     
             ; FUNCTION _USBUART_ReadOutEP (END)

             ; FUNCTION _USBUART_EnableOutEP (BEGIN)
                                           ; SOURCE LINE # 2247
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2248
                                           ; SOURCE LINE # 2249
0005 900000      R     MOV     DPTR,#epNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B D3                SETB    C
000C 9400              SUBB    A,#00H
000E 4046              JC      ?C0043
0010 900000      R     MOV     DPTR,#epNumber
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 C3                CLR     C
0017 9409              SUBB    A,#09H
0019 503B              JNC     ?C0043
                                           ; SOURCE LINE # 2250
                                           ; SOURCE LINE # 2251
001B 900000      R     MOV     DPTR,#epNumber
001E E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 69  

001F FF                MOV     R7,A
0020 EF                MOV     A,R7
0021 75F00B            MOV     B,#0BH
0024 A4                MUL     AB
0025 2400        E     ADD     A,#LOW USBUART_EP+01H
0027 F582              MOV     DPL,A
0029 E4                CLR     A
002A 3400        E     ADDC    A,#HIGH USBUART_EP+01H
002C F583              MOV     DPH,A
002E E4                CLR     A
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2254
0030 900000      R     MOV     DPTR,#epNumber
0033 E0                MOVX    A,@DPTR
0034 FF                MOV     R7,A
0035 EF                MOV     A,R7
0036 75F00B            MOV     B,#0BH
0039 A4                MUL     AB
003A 2400        E     ADD     A,#LOW USBUART_EP+05H
003C F582              MOV     DPL,A
003E E4                CLR     A
003F 3400        E     ADDC    A,#HIGH USBUART_EP+05H
0041 F583              MOV     DPH,A
0043 E0                MOVX    A,@DPTR
0044 FF                MOV     R7,A
0045 900000      R     MOV     DPTR,#epNumber
0048 E0                MOVX    A,@DPTR
0049 FE                MOV     R6,A
004A 75F010            MOV     B,#010H
004D EE                MOV     A,R6
004E 905FFE            MOV     DPTR,#05FFEH
0051 120000      E     LCALL   ?C?OFFXADD
0054 EF                MOV     A,R7
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2256
                                           ; SOURCE LINE # 2257
0056         ?C0043:
0056 22                RET     
             ; FUNCTION _USBUART_EnableOutEP (END)

             ; FUNCTION _USBUART_DisableOutEP (BEGIN)
                                           ; SOURCE LINE # 2271
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2272
                                           ; SOURCE LINE # 2273
0005 900000      R     MOV     DPTR,#epNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B D3                SETB    C
000C 9400              SUBB    A,#00H
000E 401D              JC      ?C0045
0010 900000      R     MOV     DPTR,#epNumber
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 C3                CLR     C
0017 9409              SUBB    A,#09H
0019 5012              JNC     ?C0045
                                           ; SOURCE LINE # 2274
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 70  

                                           ; SOURCE LINE # 2276
001B 900000      R     MOV     DPTR,#epNumber
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 75F010            MOV     B,#010H
0023 EF                MOV     A,R7
0024 905FFE            MOV     DPTR,#05FFEH
0027 120000      E     LCALL   ?C?OFFXADD
002A 7408              MOV     A,#08H
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2277
                                           ; SOURCE LINE # 2278
002D         ?C0045:
002D 22                RET     
             ; FUNCTION _USBUART_DisableOutEP (END)

             ; FUNCTION _USBUART_Force (BEGIN)
                                           ; SOURCE LINE # 2301
0000 900000      R     MOV     DPTR,#bState
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2302
                                           ; SOURCE LINE # 2306
0005 900000      R     MOV     DPTR,#bState
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906010            MOV     DPTR,#06010H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2307
000F 22                RET     
             ; FUNCTION _USBUART_Force (END)

             ; FUNCTION _USBUART_GetEPAckState (BEGIN)
                                           ; SOURCE LINE # 2326
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2327
                                           ; SOURCE LINE # 2328
0005 900000      R     MOV     DPTR,#cr
0008 E4                CLR     A
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2330
000A 900000      R     MOV     DPTR,#epNumber
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 D3                SETB    C
0011 9400              SUBB    A,#00H
0013 4025              JC      ?C0047
0015 900000      R     MOV     DPTR,#epNumber
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A EF                MOV     A,R7
001B C3                CLR     C
001C 9409              SUBB    A,#09H
001E 501A              JNC     ?C0047
                                           ; SOURCE LINE # 2331
                                           ; SOURCE LINE # 2332
0020 900000      R     MOV     DPTR,#epNumber
0023 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 71  

0024 FF                MOV     R7,A
0025 75F010            MOV     B,#010H
0028 EF                MOV     A,R7
0029 905FFE            MOV     DPTR,#05FFEH
002C 120000      E     LCALL   ?C?OFFXADD
002F E0                MOVX    A,@DPTR
0030 FF                MOV     R7,A
0031 EF                MOV     A,R7
0032 5410              ANL     A,#010H
0034 FF                MOV     R7,A
0035 900000      R     MOV     DPTR,#cr
0038 EF                MOV     A,R7
0039 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2333
003A         ?C0047:
                                           ; SOURCE LINE # 2335
003A 900000      R     MOV     DPTR,#cr
003D E0                MOVX    A,@DPTR
003E FF                MOV     R7,A
                                           ; SOURCE LINE # 2336
003F         ?C0048:
003F 22                RET     
             ; FUNCTION _USBUART_GetEPAckState (END)

             ; FUNCTION _USBUART_SetPowerStatus (BEGIN)
                                           ; SOURCE LINE # 2367
0000 900000      R     MOV     DPTR,#powerStatus
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2368
                                           ; SOURCE LINE # 2369
0005 900000      R     MOV     DPTR,#powerStatus
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600F              JZ      ?C0049
                                           ; SOURCE LINE # 2370
                                           ; SOURCE LINE # 2371
000D 900000      E     MOV     DPTR,#USBUART_deviceStatus
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 4401              ORL     A,#01H
0015 FF                MOV     R7,A
0016 900000      E     MOV     DPTR,#USBUART_deviceStatus
0019 EF                MOV     A,R7
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2372
001B 22                RET     
001C         ?C0049:
                                           ; SOURCE LINE # 2374
                                           ; SOURCE LINE # 2375
001C 900000      E     MOV     DPTR,#USBUART_deviceStatus
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 54FE              ANL     A,#0FEH
0024 FF                MOV     R7,A
0025 900000      E     MOV     DPTR,#USBUART_deviceStatus
0028 EF                MOV     A,R7
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2376
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 72  

                                           ; SOURCE LINE # 2377
002A         ?C0051:
002A 22                RET     
             ; FUNCTION _USBUART_SetPowerStatus (END)

             ; FUNCTION USBUART_RWUEnabled (BEGIN)
                                           ; SOURCE LINE # 2424
                                           ; SOURCE LINE # 2425
                                           ; SOURCE LINE # 2426
0000 900000      R     MOV     DPTR,#result
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2428
0005 900000      E     MOV     DPTR,#USBUART_deviceStatus
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 5402              ANL     A,#02H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 4E                ORL     A,R6
0012 6006              JZ      ?C0052
                                           ; SOURCE LINE # 2429
                                           ; SOURCE LINE # 2430
0014 900000      R     MOV     DPTR,#result
0017 7401              MOV     A,#01H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2431
001A         ?C0052:
                                           ; SOURCE LINE # 2433
001A 900000      R     MOV     DPTR,#result
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
                                           ; SOURCE LINE # 2434
001F         ?C0053:
001F 22                RET     
             ; FUNCTION USBUART_RWUEnabled (END)

             ; FUNCTION USBUART_GetDeviceAddress (BEGIN)
                                           ; SOURCE LINE # 2448
                                           ; SOURCE LINE # 2449
                                           ; SOURCE LINE # 2450
0000 906008            MOV     DPTR,#06008H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 547F              ANL     A,#07FH
0008 FF                MOV     R7,A
                                           ; SOURCE LINE # 2451
0009         ?C0054:
0009 22                RET     
             ; FUNCTION USBUART_GetDeviceAddress (END)

             ; FUNCTION USBUART_EnableSofInt (BEGIN)
                                           ; SOURCE LINE # 2462
                                           ; SOURCE LINE # 2463
                                           ; SOURCE LINE # 2470
0000 9044C2            MOV     DPTR,#044C2H
0003 7420              MOV     A,#020H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2473
C51 COMPILER V9.51   USBUART                                                               04/28/2016 18:59:23 PAGE 73  

0006 22                RET     
             ; FUNCTION USBUART_EnableSofInt (END)

             ; FUNCTION USBUART_DisableSofInt (BEGIN)
                                           ; SOURCE LINE # 2484
                                           ; SOURCE LINE # 2485
                                           ; SOURCE LINE # 2492
0000 9044CA            MOV     DPTR,#044CAH
0003 7420              MOV     A,#020H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2495
0006 22                RET     
             ; FUNCTION USBUART_DisableSofInt (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1971    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      38
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
