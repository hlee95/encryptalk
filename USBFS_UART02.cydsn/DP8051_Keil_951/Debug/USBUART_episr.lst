C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE USBUART_EPISR
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Debug\USBUART_episr.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\USBUART_episr.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB WL(
                    -2) PR(.\DP8051_Keil_951\Debug/USBUART_episr.lst) CD OT(2,SIZE) OJ(.\DP8051_Keil_951\Debug\USBUART_episr.obj)

line level    source

   1          /***************************************************************************//**
   2          * \file USBUART_episr.c
   3          * \version 3.0
   4          *
   5          * \brief
   6          *  This file contains the Data endpoint Interrupt Service Routines.
   7          *
   8          ********************************************************************************
   9          * \copyright
  10          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  11          * You may use this file only in accordance with the license, terms, conditions,
  12          * disclaimers, and limitations in the end user license agreement accompanying
  13          * the software package with which this file was provided.
  14          *******************************************************************************/
  15          
  16          #include "USBUART_pvt.h"
  17          #include "USBUART_cydmac.h"
  18          #include "cyapicallbacks.h"
  19          
  20          
  21          /***************************************
  22          * Custom Declarations
  23          ***************************************/
  24          /* `#START CUSTOM_DECLARATIONS` Place your declaration here */
  25          
  26          /* `#END` */
  27          
  28          
  29          #if (USBUART_EP1_ISR_ACTIVE)
  30              /******************************************************************************
  31              * Function Name: USBUART_EP_1_ISR
  32              ***************************************************************************//**
  33              *
  34              *  Endpoint 1 Interrupt Service Routine
  35              *
  36              ******************************************************************************/
  37              CY_ISR(USBUART_EP_1_ISR)
  38              {
  39   1      
  40   1          #ifdef USBUART_EP_1_ISR_ENTRY_CALLBACK
                      USBUART_EP_1_ISR_EntryCallback();
                  #endif /* (USBUART_EP_1_ISR_ENTRY_CALLBACK) */
  43   1      
  44   1              /* `#START EP1_USER_CODE` Place your code here */
  45   1      
  46   1              /* `#END` */
  47   1      
  48   1          #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
  49   1              !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      {
                          uint8 intEn = EA;
                          CyGlobalIntEnable;  /* Enable nested interrupts. */
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 2   

  54   1          
  55   1              USBUART_ClearSieEpInterruptSource(USBUART_SIE_INT_EP1_INTR);
  56   1                  
  57   1              /* Notifies user that transfer IN or OUT transfer is completed.
  58   1              * IN endpoint: endpoint buffer can be reloaded, Host is read data.
  59   1              * OUT endpoint: data is ready to be read from endpoint buffer. 
  60   1              */
  61   1          #if (CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)
                      if (0u != (USBUART_EP[USBUART_EP1].addr & USBUART_DIR_IN))
                  #endif /* (CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO) */
  64   1              {
  65   2                  /* Read CR0 register to clear SIE lock. */
  66   2                  (void) USBUART_SIE_EP_BASE.sieEp[USBUART_EP1].epCr0;
  67   2                  
  68   2                  /* Toggle all endpoint types except ISOC. */
  69   2                  if (USBUART_GET_EP_TYPE(USBUART_EP1) != USBUART_EP_TYPE_ISOC)
  70   2                  {
  71   3                      USBUART_EP[USBUART_EP1].epToggle ^= USBUART_EPX_CNT_DATA_TOGGLE;
  72   3                  }
  73   2      
  74   2                  /* EP_MANAGEMENT_DMA_AUTO (Ticket ID# 214187): For OUT endpoint this event is used to notify
  75   2                  * user that DMA has completed copying data from OUT endpoint which is not completely true.
  76   2                  * Because last chunk of data is being copied.
  77   2                  * For CY_PSOC 3/5LP: it is acceptable as DMA is really fast.
  78   2                  * For CY_PSOC4: this event is set in Arbiter interrupt (source is DMA_TERMIN).
  79   2                  */
  80   2                  USBUART_EP[USBUART_EP1].apiEpState = USBUART_EVENT_PENDING;
  81   2              }
  82   1      
  83   1          #if (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO))
  84   1              #if (defined(USBUART_ENABLE_MIDI_STREAMING) && \
  85   1                  !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                          if (USBUART_midi_out_ep == USBUART_EP1)
                          {
                              USBUART_MIDI_OUT_Service();
                          }
                      #endif /* (USBUART_ISR_SERVICE_MIDI_OUT) */
  91   1          #endif /* (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)) */
  92   1          
  93   1              /* `#START EP1_END_USER_CODE` Place your code here */
  94   1      
  95   1              /* `#END` */
  96   1      
  97   1          #ifdef USBUART_EP_1_ISR_EXIT_CALLBACK
                      USBUART_EP_1_ISR_ExitCallback();
                  #endif /* (USBUART_EP_1_ISR_EXIT_CALLBACK) */
 100   1      
 101   1          #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
 102   1              !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      
                          EA = intEn; /* Restore nested interrupt configuration. */
                      }
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
 107   1          }
 108          
 109          #endif /* (USBUART_EP1_ISR_ACTIVE) */
 110          
 111          
 112          #if (USBUART_EP2_ISR_ACTIVE)
 113              /*******************************************************************************
 114              * Function Name: USBUART_EP_2_ISR
 115              ****************************************************************************//**
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 3   

 116              *
 117              *  Endpoint 2 Interrupt Service Routine.
 118              *
 119              *******************************************************************************/
 120              CY_ISR(USBUART_EP_2_ISR)
 121              {
 122   1          #ifdef USBUART_EP_2_ISR_ENTRY_CALLBACK
                      USBUART_EP_2_ISR_EntryCallback();
                  #endif /* (USBUART_EP_2_ISR_ENTRY_CALLBACK) */
 125   1      
 126   1              /* `#START EP2_USER_CODE` Place your code here */
 127   1      
 128   1              /* `#END` */
 129   1      
 130   1          #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
 131   1              !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      {
                          uint8 intEn = EA;
                          CyGlobalIntEnable;  /* Enable nested interrupts. */
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
 136   1      
 137   1              USBUART_ClearSieEpInterruptSource(USBUART_SIE_INT_EP2_INTR);
 138   1      
 139   1              /* Notifies user that transfer IN or OUT transfer is completed.
 140   1              * IN endpoint: endpoint buffer can be reloaded, Host is read data.
 141   1              * OUT endpoint: data is ready to be read from endpoint buffer. 
 142   1              */
 143   1          #if (CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)
                      if (0u != (USBUART_EP[USBUART_EP2].addr & USBUART_DIR_IN))
                  #endif /* (CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO) */
 146   1              {            
 147   2                  /* Read CR0 register to clear SIE lock. */
 148   2                  (void) USBUART_SIE_EP_BASE.sieEp[USBUART_EP2].epCr0;
 149   2                  
 150   2                  /* Toggle all endpoint types except ISOC. */
 151   2                  if (USBUART_GET_EP_TYPE(USBUART_EP2) != USBUART_EP_TYPE_ISOC)
 152   2                  {
 153   3                      USBUART_EP[USBUART_EP2].epToggle ^= USBUART_EPX_CNT_DATA_TOGGLE;
 154   3                  }
 155   2      
 156   2                  /* EP_MANAGEMENT_DMA_AUTO (Ticket ID# 214187): For OUT endpoint this event is used to notify
 157   2                  * user that DMA has completed copying data from OUT endpoint which is not completely true.
 158   2                  * Because last chunk of data is being copied.
 159   2                  * For CY_PSOC 3/5LP: it is acceptable as DMA is really fast.
 160   2                  * For CY_PSOC4: this event is set in Arbiter interrupt (source is DMA_TERMIN).
 161   2                  */
 162   2                  USBUART_EP[USBUART_EP2].apiEpState = USBUART_EVENT_PENDING;
 163   2              }
 164   1      
 165   1          #if (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO))
 166   1              #if (defined(USBUART_ENABLE_MIDI_STREAMING) && \
 167   1                  !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                          if (USBUART_midi_out_ep == USBUART_EP2)
                          {
                              USBUART_MIDI_OUT_Service();
                          }
                      #endif /* (USBUART_ISR_SERVICE_MIDI_OUT) */
 173   1          #endif /* (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)) */        
 174   1          
 175   1              /* `#START EP2_END_USER_CODE` Place your code here */
 176   1      
 177   1              /* `#END` */
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 4   

 178   1      
 179   1          #ifdef USBUART_EP_2_ISR_EXIT_CALLBACK
                      USBUART_EP_2_ISR_ExitCallback();
                  #endif /* (USBUART_EP_2_ISR_EXIT_CALLBACK) */
 182   1      
 183   1          #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
 184   1              !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      
                          EA = intEn; /* Restore nested interrupt configuration. */
                      }
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
 189   1          }
 190          #endif /* (USBUART_EP2_ISR_ACTIVE) */
 191          
 192          
 193          #if (USBUART_EP3_ISR_ACTIVE)
 194              /*******************************************************************************
 195              * Function Name: USBUART_EP_3_ISR
 196              ****************************************************************************//**
 197              *
 198              *  Endpoint 3 Interrupt Service Routine.
 199              *
 200              *******************************************************************************/
 201              CY_ISR(USBUART_EP_3_ISR)
 202              {
 203   1          #ifdef USBUART_EP_3_ISR_ENTRY_CALLBACK
                      USBUART_EP_3_ISR_EntryCallback();
                  #endif /* (USBUART_EP_3_ISR_ENTRY_CALLBACK) */
 206   1      
 207   1              /* `#START EP3_USER_CODE` Place your code here */
 208   1      
 209   1              /* `#END` */
 210   1      
 211   1          #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
 212   1              !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      {
                          uint8 intEn = EA;
                          CyGlobalIntEnable;  /* Enable nested interrupts. */
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
 217   1      
 218   1              USBUART_ClearSieEpInterruptSource(USBUART_SIE_INT_EP3_INTR);    
 219   1      
 220   1              /* Notifies user that transfer IN or OUT transfer is completed.
 221   1              * IN endpoint: endpoint buffer can be reloaded, Host is read data.
 222   1              * OUT endpoint: data is ready to be read from endpoint buffer. 
 223   1              */
 224   1          #if (CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)
                      if (0u != (USBUART_EP[USBUART_EP3].addr & USBUART_DIR_IN))
                  #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
 227   1              {            
 228   2                  /* Read CR0 register to clear SIE lock. */
 229   2                  (void) USBUART_SIE_EP_BASE.sieEp[USBUART_EP3].epCr0;
 230   2      
 231   2                  /* Toggle all endpoint types except ISOC. */
 232   2                  if (USBUART_GET_EP_TYPE(USBUART_EP3) != USBUART_EP_TYPE_ISOC)
 233   2                  {
 234   3                      USBUART_EP[USBUART_EP3].epToggle ^= USBUART_EPX_CNT_DATA_TOGGLE;
 235   3                  }
 236   2      
 237   2                  /* EP_MANAGEMENT_DMA_AUTO (Ticket ID# 214187): For OUT endpoint this event is used to notify
 238   2                  * user that DMA has completed copying data from OUT endpoint which is not completely true.
 239   2                  * Because last chunk of data is being copied.
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 5   

 240   2                  * For CY_PSOC 3/5LP: it is acceptable as DMA is really fast.
 241   2                  * For CY_PSOC4: this event is set in Arbiter interrupt (source is DMA_TERMIN).
 242   2                  */
 243   2                  USBUART_EP[USBUART_EP3].apiEpState = USBUART_EVENT_PENDING;
 244   2              }
 245   1      
 246   1          #if (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO))
 247   1              #if (defined(USBUART_ENABLE_MIDI_STREAMING) && \
 248   1                  !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                          if (USBUART_midi_out_ep == USBUART_EP3)
                          {
                              USBUART_MIDI_OUT_Service();
                          }
                      #endif /* (USBUART_ISR_SERVICE_MIDI_OUT) */
 254   1          #endif /* (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)) */        
 255   1      
 256   1              /* `#START EP3_END_USER_CODE` Place your code here */
 257   1      
 258   1              /* `#END` */
 259   1      
 260   1          #ifdef USBUART_EP_3_ISR_EXIT_CALLBACK
                      USBUART_EP_3_ISR_ExitCallback();
                  #endif /* (USBUART_EP_3_ISR_EXIT_CALLBACK) */
 263   1      
 264   1          #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
 265   1              !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      
                          EA = intEn; /* Restore nested interrupt configuration. */
                      }
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
 270   1          }
 271          #endif /* (USBUART_EP3_ISR_ACTIVE) */
 272          
 273          
 274          #if (USBUART_EP4_ISR_ACTIVE)
                  /*******************************************************************************
                  * Function Name: USBUART_EP_4_ISR
                  ****************************************************************************//**
                  *
                  *  Endpoint 4 Interrupt Service Routine.
                  *
                  *******************************************************************************/
                  CY_ISR(USBUART_EP_4_ISR)
                  {
                  #ifdef USBUART_EP_4_ISR_ENTRY_CALLBACK
                      USBUART_EP_4_ISR_EntryCallback();
                  #endif /* (USBUART_EP_4_ISR_ENTRY_CALLBACK) */
              
                      /* `#START EP4_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                  #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
                      !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      {
                          uint8 intEn = EA;
                          CyGlobalIntEnable;  /* Enable nested interrupts. */
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
              
                      USBUART_ClearSieEpInterruptSource(USBUART_SIE_INT_EP4_INTR);
                      
                      /* Notifies user that transfer IN or OUT transfer is completed.
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 6   

                      * IN endpoint: endpoint buffer can be reloaded, Host is read data.
                      * OUT endpoint: data is ready to read from endpoint buffer. 
                      */
                  #if (CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)
                      if (0u != (USBUART_EP[USBUART_EP4].addr & USBUART_DIR_IN))
                  #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                      {
                          /* Read CR0 register to clear SIE lock. */
                          (void) USBUART_SIE_EP_BASE.sieEp[USBUART_EP4].epCr0;
              
                          /* Toggle all endpoint types except ISOC. */
                          if (USBUART_GET_EP_TYPE(USBUART_EP4) != USBUART_EP_TYPE_ISOC)
                          {
                              USBUART_EP[USBUART_EP4].epToggle ^= USBUART_EPX_CNT_DATA_TOGGLE;
                          }
              
                          /* EP_MANAGEMENT_DMA_AUTO (Ticket ID# 214187): For OUT endpoint this event is used to notify
                          * user that DMA has completed copying data from OUT endpoint which is not completely true.
                          * Because last chunk of data is being copied.
                          * For CY_PSOC 3/5LP: it is acceptable as DMA is really fast.
                          * For CY_PSOC4: this event is set in Arbiter interrupt (source is DMA_TERMIN).
                          */
                          USBUART_EP[USBUART_EP4].apiEpState = USBUART_EVENT_PENDING;
                      }
              
                  #if (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO))
                      #if (defined(USBUART_ENABLE_MIDI_STREAMING) && \
                          !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                          if(USBUART_midi_out_ep == USBUART_EP4)
                          {
                              USBUART_MIDI_OUT_Service();
                          }
                      #endif /* (USBUART_ISR_SERVICE_MIDI_OUT) */
                  #endif /* (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)) */        
              
                      /* `#START EP4_END_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                  #ifdef USBUART_EP_4_ISR_EXIT_CALLBACK
                      USBUART_EP_4_ISR_ExitCallback();
                  #endif /* (USBUART_EP_4_ISR_EXIT_CALLBACK) */
              
                  #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
                      !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      
                          EA = intEn; /* Restore nested interrupt configuration. */
                      }
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
                  }
              #endif /* (USBUART_EP4_ISR_ACTIVE) */
 353          
 354          
 355          #if (USBUART_EP5_ISR_ACTIVE)
                  /*******************************************************************************
                  * Function Name: USBUART_EP_5_ISR
                  ****************************************************************************//**
                  *
                  *  Endpoint 5 Interrupt Service Routine
                  *
                  *
                  *******************************************************************************/
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 7   

                  CY_ISR(USBUART_EP_5_ISR)
                  {
                  #ifdef USBUART_EP_5_ISR_ENTRY_CALLBACK
                      USBUART_EP_5_ISR_EntryCallback();
                  #endif /* (USBUART_EP_5_ISR_ENTRY_CALLBACK) */
              
                      /* `#START EP5_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                  #if (defined(USBUART_ENABLE_MIDI_STREAMING) && !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && \
                               USBUART_ISR_SERVICE_MIDI_OUT && CY_PSOC3)
                      {
                          uint8 intEn = EA;
                          CyGlobalIntEnable;  /* Enable nested interrupts. */
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
              
                      USBUART_ClearSieEpInterruptSource(USBUART_SIE_INT_EP5_INTR);
                  
                      /* Notifies user that transfer IN or OUT transfer is completed.
                      * IN endpoint: endpoint buffer can be reloaded, Host is read data.
                      * OUT endpoint: data is ready to read from endpoint buffer. 
                      */
                  #if (CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)
                      if (0u != (USBUART_EP[USBUART_EP5].addr & USBUART_DIR_IN))
                  #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                      {            
                          /* Read CR0 register to clear SIE lock. */
                          (void) USBUART_SIE_EP_BASE.sieEp[USBUART_EP5].epCr0;
              
                          /* Toggle all endpoint types except ISOC. */
                          if (USBUART_GET_EP_TYPE(USBUART_EP5) != USBUART_EP_TYPE_ISOC)
                          {
                              USBUART_EP[USBUART_EP5].epToggle ^= USBUART_EPX_CNT_DATA_TOGGLE;
                          }
              
                          /* EP_MANAGEMENT_DMA_AUTO (Ticket ID# 214187): For OUT endpoint this event is used to notify
                          * user that DMA has completed copying data from OUT endpoint which is not completely true.
                          * Because last chunk of data is being copied.
                          * For CY_PSOC 3/5LP: it is acceptable as DMA is really fast.
                          * For CY_PSOC4: this event is set in Arbiter interrupt (source is DMA_TERMIN).
                          */
                          USBUART_EP[USBUART_EP5].apiEpState = USBUART_EVENT_PENDING;
                      }
              
                  #if (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO))        
                      #if (defined(USBUART_ENABLE_MIDI_STREAMING) && \
                          !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                          if (USBUART_midi_out_ep == USBUART_EP5)
                          {
                              USBUART_MIDI_OUT_Service();
                          }
                      #endif /* (USBUART_ISR_SERVICE_MIDI_OUT) */
                  #endif /* (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)) */
              
                      /* `#START EP5_END_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                  #ifdef USBUART_EP_5_ISR_EXIT_CALLBACK
                      USBUART_EP_5_ISR_ExitCallback();
                  #endif /* (USBUART_EP_5_ISR_EXIT_CALLBACK) */
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 8   

              
                  #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
                      !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      
                          EA = intEn; /* Restore nested interrupt configuration. */
                      }
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
                  }
              #endif /* (USBUART_EP5_ISR_ACTIVE) */
 435          
 436          
 437          #if (USBUART_EP6_ISR_ACTIVE)
                  /*******************************************************************************
                  * Function Name: USBUART_EP_6_ISR
                  ****************************************************************************//**
                  *
                  *  Endpoint 6 Interrupt Service Routine.
                  *
                  *
                  *******************************************************************************/
                  CY_ISR(USBUART_EP_6_ISR)
                  {
                  #ifdef USBUART_EP_6_ISR_ENTRY_CALLBACK
                      USBUART_EP_6_ISR_EntryCallback();
                  #endif /* (USBUART_EP_6_ISR_ENTRY_CALLBACK) */
              
                      /* `#START EP6_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                  #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
                      !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      {
                          uint8 intEn = EA;
                          CyGlobalIntEnable;  /* Enable nested interrupts. */
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
              
                      USBUART_ClearSieEpInterruptSource(USBUART_SIE_INT_EP6_INTR);
                      
                      /* Notifies user that transfer IN or OUT transfer is completed.
                      * IN endpoint: endpoint buffer can be reloaded, Host is read data.
                      * OUT endpoint: data is ready to read from endpoint buffer. 
                      */
                  #if (CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)
                      if (0u != (USBUART_EP[USBUART_EP6].addr & USBUART_DIR_IN))
                  #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                      {
                          /* Read CR0 register to clear SIE lock. */
                          (void) USBUART_SIE_EP_BASE.sieEp[USBUART_EP6].epCr0;
              
                          /* Toggle all endpoint types except ISOC. */
                          if (USBUART_GET_EP_TYPE(USBUART_EP6) != USBUART_EP_TYPE_ISOC)
                          {
                              USBUART_EP[USBUART_EP6].epToggle ^= USBUART_EPX_CNT_DATA_TOGGLE;
                          }
                          
                          /* EP_MANAGEMENT_DMA_AUTO (Ticket ID# 214187): For OUT endpoint this event is used to notify
                          * user that DMA has completed copying data from OUT endpoint which is not completely true.
                          * Because last chunk of data is being copied.
                          * For CY_PSOC 3/5LP: it is acceptable as DMA is really fast.
                          * For CY_PSOC4: this event is set in Arbiter interrupt (source is DMA_TERMIN).
                          */
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 9   

                          USBUART_EP[USBUART_EP6].apiEpState = USBUART_EVENT_PENDING;
                      }
              
                  #if (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO))
                      #if (defined(USBUART_ENABLE_MIDI_STREAMING) && \
                          !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                          if (USBUART_midi_out_ep == USBUART_EP6)
                          {
                              USBUART_MIDI_OUT_Service();
                          }
                      #endif /* (USBUART_ISR_SERVICE_MIDI_OUT) */
                  #endif /* (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)) */
              
                      /* `#START EP6_END_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                  #ifdef USBUART_EP_6_ISR_EXIT_CALLBACK
                      USBUART_EP_6_ISR_ExitCallback();
                  #endif /* (USBUART_EP_6_ISR_EXIT_CALLBACK) */
              
                  #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
                      !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      
                          EA = intEn; /* Restore nested interrupt configuration. */
                      }
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
                  }
              #endif /* (USBUART_EP6_ISR_ACTIVE) */
 517          
 518          
 519          #if (USBUART_EP7_ISR_ACTIVE)
                  /*******************************************************************************
                  * Function Name: USBUART_EP_7_ISR
                  ****************************************************************************//**
                  *
                  *  Endpoint 7 Interrupt Service Routine.
                  *
                  *
                  *******************************************************************************/
                  CY_ISR(USBUART_EP_7_ISR)
                  {
                  #ifdef USBUART_EP_7_ISR_ENTRY_CALLBACK
                      USBUART_EP_7_ISR_EntryCallback();
                  #endif /* (USBUART_EP_7_ISR_ENTRY_CALLBACK) */
              
                      /* `#START EP7_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                  #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
                      !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      {
                          uint8 intEn = EA;
                          CyGlobalIntEnable;  /* Enable nested interrupts. */
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
                  
                      USBUART_ClearSieEpInterruptSource(USBUART_SIE_INT_EP7_INTR);
                      
                      /* Notifies user that transfer IN or OUT transfer is completed.
                      * IN endpoint: endpoint buffer can be reloaded, Host is read data.
                      * OUT endpoint: data is ready to read from endpoint buffer. 
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 10  

                      */
                  #if (CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)
                      if (0u != (USBUART_EP[USBUART_EP7].addr & USBUART_DIR_IN))
                  #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                      {           
                          /* Read CR0 register to clear SIE lock. */
                          (void) USBUART_SIE_EP_BASE.sieEp[USBUART_EP7].epCr0;
              
                          /* Toggle all endpoint types except ISOC. */
                          if (USBUART_GET_EP_TYPE(USBUART_EP7) != USBUART_EP_TYPE_ISOC)
                          {
                              USBUART_EP[USBUART_EP7].epToggle ^= USBUART_EPX_CNT_DATA_TOGGLE;
                          }
                          
                          /* EP_MANAGEMENT_DMA_AUTO (Ticket ID# 214187): For OUT endpoint this event is used to notify
                          * user that DMA has completed copying data from OUT endpoint which is not completely true.
                          * Because last chunk of data is being copied.
                          * For CY_PSOC 3/5LP: it is acceptable as DMA is really fast.
                          * For CY_PSOC4: this event is set in Arbiter interrupt (source is DMA_TERMIN).
                          */
                          USBUART_EP[USBUART_EP7].apiEpState = USBUART_EVENT_PENDING;
                      }
              
              
                  #if (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO))
                      #if (defined(USBUART_ENABLE_MIDI_STREAMING) && \
                          !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                          if(USBUART_midi_out_ep == USBUART_EP7)
                          {
                              USBUART_MIDI_OUT_Service();
                          }
                      #endif /* (USBUART_ISR_SERVICE_MIDI_OUT) */
                  #endif /* (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)) */
              
                      /* `#START EP7_END_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                  #ifdef USBUART_EP_7_ISR_EXIT_CALLBACK
                      USBUART_EP_7_ISR_ExitCallback();
                  #endif /* (USBUART_EP_7_ISR_EXIT_CALLBACK) */
              
                  #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
                      !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      
                          EA = intEn; /* Restore nested interrupt configuration. */
                      }
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
                  }
              #endif /* (USBUART_EP7_ISR_ACTIVE) */
 600          
 601          
 602          #if (USBUART_EP8_ISR_ACTIVE)
                  /*******************************************************************************
                  * Function Name: USBUART_EP_8_ISR
                  ****************************************************************************//**
                  *
                  *  Endpoint 8 Interrupt Service Routine
                  *
                  *
                  *******************************************************************************/
                  CY_ISR(USBUART_EP_8_ISR)
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 11  

                  {
                  #ifdef USBUART_EP_8_ISR_ENTRY_CALLBACK
                      USBUART_EP_8_ISR_EntryCallback();
                  #endif /* (USBUART_EP_8_ISR_ENTRY_CALLBACK) */
              
                      /* `#START EP8_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                  #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
                      !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      {
                          uint8 intEn = EA;
                          CyGlobalIntEnable;  /* Enable nested interrupts. */
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
              
                      USBUART_ClearSieEpInterruptSource(USBUART_SIE_INT_EP8_INTR);
                      
                      /* Notifies user that transfer IN or OUT transfer is completed.
                      * IN endpoint: endpoint buffer can be reloaded, Host is read data.
                      * OUT endpoint: data is ready to read from endpoint buffer. 
                      */
                  #if (CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)
                      if (0u != (USBUART_EP[USBUART_EP8].addr & USBUART_DIR_IN))
                  #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
                      {
                          /* Read CR0 register to clear SIE lock. */
                          (void) USBUART_SIE_EP_BASE.sieEp[USBUART_EP8].epCr0;
              
                          /* Toggle all endpoint types except ISOC. */
                          if (USBUART_GET_EP_TYPE(USBUART_EP8) != USBUART_EP_TYPE_ISOC)
                          {
                              USBUART_EP[USBUART_EP8].epToggle ^= USBUART_EPX_CNT_DATA_TOGGLE;
                          }
              
                          /* EP_MANAGEMENT_DMA_AUTO (Ticket ID# 214187): For OUT endpoint this event is used to notify
                          * user that DMA has completed copying data from OUT endpoint which is not completely true.
                          * Because last chunk of data is being copied.
                          * For CY_PSOC 3/5LP: it is acceptable as DMA is really fast.
                          * For CY_PSOC4: this event is set in Arbiter interrupt (source is DMA_TERMIN).
                          */
                          USBUART_EP[USBUART_EP8].apiEpState = USBUART_EVENT_PENDING;
                      }
              
                  #if (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO))
                      #if (defined(USBUART_ENABLE_MIDI_STREAMING) && \
                          !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                          if (USBUART_midi_out_ep == USBUART_EP8)
                          {
                              USBUART_MIDI_OUT_Service();
                          }
                      #endif /* (USBUART_ISR_SERVICE_MIDI_OUT) */
                  #endif /* (!(CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)) */
              
                      /* `#START EP8_END_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                  #ifdef USBUART_EP_8_ISR_EXIT_CALLBACK
                      USBUART_EP_8_ISR_ExitCallback();
                  #endif /* (USBUART_EP_8_ISR_EXIT_CALLBACK) */
              
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 12  

                  #if (CY_PSOC3 && defined(USBUART_ENABLE_MIDI_STREAMING) && \
                      !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                      
                          EA = intEn; /* Restore nested interrupt configuration. */
                      }
                  #endif /* (CY_PSOC3 && USBUART_ISR_SERVICE_MIDI_OUT) */
                  }
              #endif /* (USBUART_EP8_ISR_ACTIVE) */
 682          
 683          
 684          #if (USBUART_SOF_ISR_ACTIVE)
 685              /*******************************************************************************
 686              * Function Name: USBUART_SOF_ISR
 687              ****************************************************************************//**
 688              *
 689              *  Start of Frame Interrupt Service Routine.
 690              *
 691              *
 692              *******************************************************************************/
 693              CY_ISR(USBUART_SOF_ISR)
 694              {
 695   1          #ifdef USBUART_SOF_ISR_ENTRY_CALLBACK
                      USBUART_SOF_ISR_EntryCallback();
                  #endif /* (USBUART_SOF_ISR_ENTRY_CALLBACK) */
 698   1      
 699   1              /* `#START SOF_USER_CODE` Place your code here */
 700   1      
 701   1              /* `#END` */
 702   1      
 703   1              USBUART_ClearSieInterruptSource(USBUART_INTR_SIE_SOF_INTR);
 704   1      
 705   1          #ifdef USBUART_SOF_ISR_EXIT_CALLBACK
                      USBUART_SOF_ISR_ExitCallback();
                  #endif /* (USBUART_SOF_ISR_EXIT_CALLBACK) */
 708   1          }
 709          #endif /* (USBUART_SOF_ISR_ACTIVE) */
 710          
 711          
 712          #if (USBUART_BUS_RESET_ISR_ACTIVE)
 713          /*******************************************************************************
 714          * Function Name: USBUART_BUS_RESET_ISR
 715          ****************************************************************************//**
 716          *
 717          *  USB Bus Reset Interrupt Service Routine.  Calls _Start with the same
 718          *  parameters as the last USER call to _Start
 719          *
 720          *
 721          *******************************************************************************/
 722          CY_ISR(USBUART_BUS_RESET_ISR)
 723          {
 724   1      #ifdef USBUART_BUS_RESET_ISR_ENTRY_CALLBACK
                  USBUART_BUS_RESET_ISR_EntryCallback();
              #endif /* (USBUART_BUS_RESET_ISR_ENTRY_CALLBACK) */
 727   1      
 728   1          /* `#START BUS_RESET_USER_CODE` Place your code here */
 729   1      
 730   1          /* `#END` */
 731   1      
 732   1          USBUART_ClearSieInterruptSource(USBUART_INTR_SIE_BUS_RESET_INTR);
 733   1      
 734   1          USBUART_ReInitComponent();
 735   1      
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 13  

 736   1      #ifdef USBUART_BUS_RESET_ISR_EXIT_CALLBACK
                  USBUART_BUS_RESET_ISR_ExitCallback();
              #endif /* (USBUART_BUS_RESET_ISR_EXIT_CALLBACK) */
 739   1      }
 740          #endif /* (USBUART_BUS_RESET_ISR_ACTIVE) */
 741          
 742          
 743          #if (USBUART_LPM_ACTIVE)
              /***************************************************************************
              * Function Name: USBUART_INTR_LPM_ISR
              ************************************************************************//**
              *
              *   Interrupt Service Routine for LPM of the interrupt sources.
              *
              *
              ***************************************************************************/
              CY_ISR(USBUART_LPM_ISR)
              {
              #ifdef USBUART_LPM_ISR_ENTRY_CALLBACK
                  USBUART_LPM_ISR_EntryCallback();
              #endif /* (USBUART_LPM_ISR_ENTRY_CALLBACK) */
              
                  /* `#START LPM_BEGIN_USER_CODE` Place your code here */
              
                  /* `#END` */
              
                  USBUART_ClearSieInterruptSource(USBUART_INTR_SIE_LPM_INTR);
              
                  /* `#START LPM_END_USER_CODE` Place your code here */
              
                  /* `#END` */
              
              #ifdef USBUART_LPM_ISR_EXIT_CALLBACK
                  USBUART_LPM_ISR_ExitCallback();
              #endif /* (USBUART_LPM_ISR_EXIT_CALLBACK) */
              }
              #endif /* (USBUART_LPM_ACTIVE) */
 773          
 774          
 775          #if (USBUART_EP_MANAGEMENT_DMA && USBUART_ARB_ISR_ACTIVE)
                  /***************************************************************************
                  * Function Name: USBUART_ARB_ISR
                  ************************************************************************//**
                  *
                  *  Arbiter Interrupt Service Routine.
                  *
                  *
                  ***************************************************************************/
                  CY_ISR(USBUART_ARB_ISR)
                  {
                      uint8 arbIntrStatus;
                      uint8 epStatus;
                      uint8 ep = USBUART_EP1;
              
                  #ifdef USBUART_ARB_ISR_ENTRY_CALLBACK
                      USBUART_ARB_ISR_EntryCallback();
                  #endif /* (USBUART_ARB_ISR_ENTRY_CALLBACK) */
              
                      /* `#START ARB_BEGIN_USER_CODE` Place your code here */
              
                      /* `#END` */
              
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 14  

                      /* Get pending ARB interrupt sources. */
                      arbIntrStatus = USBUART_ARB_INT_SR_REG;
              
                      while (0u != arbIntrStatus)
                      {
                          /* Check which EP is interrupt source. */
                          if (0u != (arbIntrStatus & 0x01u))
                          {
                              /* Get endpoint enable interrupt sources. */
                              epStatus = (USBUART_ARB_EP_BASE.arbEp[ep].epSr & USBUART_ARB_EP_BASE.arbEp[ep].epIntEn);
              
                              /* Handle IN endpoint buffer full event: happens only once when endpoint buffer is loaded.
             - */
                              if (0u != (epStatus & USBUART_ARB_EPX_INT_IN_BUF_FULL))
                              {
                                  if (0u != (USBUART_EP[ep].addr & USBUART_DIR_IN))
                                  {
                                      /* Clear data ready status. */
                                      USBUART_ARB_EP_BASE.arbEp[ep].epCfg &= (uint8) ~USBUART_ARB_EPX_CFG_IN_DATA_RDY;
              
                                  #if (CY_PSOC3 || CY_PSOC5LP)
                                      #if (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u))
                                          /* Set up common area DMA with rest of data. */
                                          if(USBUART_inLength[ep] > USBUART_DMA_BYTES_PER_BURST)
                                          {
                                              USBUART_LoadNextInEP(ep, 0u);
                                          }
                                          else
                                          {
                                              USBUART_inBufFull[ep] = 1u;
                                          }
                                      #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO && (USBUART_EP_DMA_AUTO_OPT == 0u)) */
                                  #endif /* (CY_PSOC3 || CY_PSOC5LP) */
              
                                      /* Arm IN endpoint. */
                                      USBUART_SIE_EP_BASE.sieEp[ep].epCr0 = USBUART_EP[ep].epMode;
              
                                  #if (defined(USBUART_ENABLE_MIDI_STREAMING) && USBUART_ISR_SERVICE_MIDI_IN)
                                      if (ep == USBUART_midi_in_ep)
                                      {
                                          /* Clear MIDI input pointer. */
                                          USBUART_midiInPointer = 0u;
                                      }
                                  #endif /* (USBUART_ENABLE_MIDI_STREAMING) */
                                  }
                              }
              
                          #if (USBUART_EP_MANAGEMENT_DMA_MANUAL)
                              /* Handle DMA completion event for OUT endpoints. */
                              if (0u != (epStatus & USBUART_ARB_EPX_SR_DMA_GNT))
                              {
                                  if (0u == (USBUART_EP[ep].addr & USBUART_DIR_IN))
                                  {
                                      /* Notify user that data has been copied from endpoint buffer. */
                                      USBUART_EP[ep].apiEpState = USBUART_NO_EVENT_PENDING;
              
                                      /* DMA done coping data: OUT endpoint has to be re-armed by user. */
                                  }
                              }
                          #endif /* (USBUART_EP_MANAGEMENT_DMA_MANUAL) */
              
                          #if (CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO)
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 15  

                              /* Handle DMA completion event for OUT endpoints. */
                              if (0u != (epStatus & USBUART_ARB_EPX_INT_DMA_TERMIN))
                              {
                                  uint32 channelNum = USBUART_DmaChan[ep];
              
                                  /* Restore burst counter for endpoint. */
                                  USBUART_DmaEpBurstCnt[ep] = USBUART_DmaEpBurstCntBackup[ep];
              
                                  /* Disable DMA channel to restore descriptor configuration. The on-going transfer is a
             -borted. */
                                  USBUART_CyDmaChDisable(channelNum);
              
                                  /* Generate DMA tr_out signal to notify USB IP that DMA is done. This signal is not ge
             -nerated
                                  * when transfer was aborted (it occurs when host writes less bytes than buffer size).
                                  */
                                  USBUART_CyDmaTriggerOut(USBUART_DmaBurstEndOut[ep]);
              
                                  /* Restore destination address for output endpoint. */
                                  USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR0, (void*) ((uint32) USBUART_D
             -maEpBufferAddrBackup[ep]));
                                  USBUART_CyDmaSetDstAddress(channelNum, USBUART_DMA_DESCR1, (void*) ((uint32) USBUART_D
             -maEpBufferAddrBackup[ep] +
                                                                                                                        
             -         USBUART_DMA_BYTES_PER_BURST));
              
                                  /* Restore number of data elements to transfer which was adjusted for last burst. */
                                  if (0u != (USBUART_DmaEpLastBurstEl[ep] & USBUART_DMA_DESCR_REVERT))
                                  {
                                      USBUART_CyDmaSetNumDataElements(channelNum, (USBUART_DmaEpLastBurstEl[ep] >> USBUA
             -RT_DMA_DESCR_SHIFT),
                                                                                           USBUART_DMA_GET_MAX_ELEM_PER_
             -BURST(USBUART_DmaEpLastBurstEl[ep]));
                                  }
              
                                  /* Validate descriptor 0 and 1 (also reset current state). Command to start with descr
             -iptor 0. */
                                  USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR0);
                                  USBUART_CyDmaValidateDescriptor(channelNum, USBUART_DMA_DESCR1);
                                  USBUART_CyDmaSetDescriptor0Next(channelNum);
              
                                  /* Enable DMA channel: configuration complete. */
                                  USBUART_CyDmaChEnable(channelNum);
                                  
                                  
                                  /* Read CR0 register to clear SIE lock. */
                                  (void) USBUART_SIE_EP_BASE.sieEp[ep].epCr0;
                                  
                                  /* Toggle all endpoint types except ISOC. */
                                  if (USBUART_GET_EP_TYPE(ep) != USBUART_EP_TYPE_ISOC)
                                  {
                                      USBUART_EP[ep].epToggle ^= USBUART_EPX_CNT_DATA_TOGGLE;
                                  }
                          
                                  /* Notify user that data has been copied from endpoint buffer. */
                                  USBUART_EP[ep].apiEpState = USBUART_EVENT_PENDING;
                                  
                              #if (defined(USBUART_ENABLE_MIDI_STREAMING) && \
                                  !defined(USBUART_MAIN_SERVICE_MIDI_OUT) && USBUART_ISR_SERVICE_MIDI_OUT)
                                  if (USBUART_midi_out_ep == ep)
                                  {
                                      USBUART_MIDI_OUT_Service();
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 16  

                                  }
                              #endif /* (USBUART_ISR_SERVICE_MIDI_OUT) */
                              }
                          #endif /* (CY_PSOC4 && USBUART_EP_MANAGEMENT_DMA_AUTO) */
              
              
                              /* `#START ARB_USER_CODE` Place your code here for handle Buffer Underflow/Overflow */
              
                              /* `#END` */
              
                          #ifdef USBUART_ARB_ISR_CALLBACK
                              USBUART_ARB_ISR_Callback(ep, epStatus);
                          #endif /* (USBUART_ARB_ISR_CALLBACK) */
              
                              /* Clear serviced endpoint interrupt sources. */
                              USBUART_ARB_EP_BASE.arbEp[ep].epSr = epStatus;
                          }
              
                          ++ep;
                          arbIntrStatus >>= 1u;
                      }
              
                      /* `#START ARB_END_USER_CODE` Place your code here */
              
                      /* `#END` */
              
                  #ifdef USBUART_ARB_ISR_EXIT_CALLBACK
                      USBUART_ARB_ISR_ExitCallback();
                  #endif /* (USBUART_ARB_ISR_EXIT_CALLBACK) */
                  }
              
              #endif /*  (USBUART_ARB_ISR_ACTIVE && USBUART_EP_MANAGEMENT_DMA) */
 945          
 946          
 947          #if (USBUART_EP_MANAGEMENT_DMA_AUTO)
              #if (CY_PSOC4)
                  #if (USBUART_DMA1_ACTIVE)
                      /******************************************************************************
                      * Function Name: USBUART_EP1_DMA_DONE_ISR
                      ***************************************************************************//**
                      *
                      *  Endpoint 1 DMA Done Interrupt Service Routine.
                      *
                      *
                      ******************************************************************************/
                      void USBUART_EP1_DMA_DONE_ISR(void)
                      {
                          uint32 nextAddr;
              
                          /* Manage data elements which remain to transfer. */
                          if (0u != USBUART_DmaEpBurstCnt[USBUART_EP1])
                          {
                              /* Decrement burst counter. */
                              --USBUART_DmaEpBurstCnt[USBUART_EP1];
                          }
                          else
                          {
                              /* Adjust length of last burst. */
                              USBUART_CyDmaSetNumDataElements(USBUART_EP1_DMA_CH,
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP1] >>
             - USBUART_DMA_DESCR_SHIFT),
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP1] & 
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 17  

             - USBUART_DMA_BURST_BYTES_MASK));
                          }
              
                          /* Advance source for input endpoint or destination for output endpoint. */
                          if (0u != (USBUART_EP[USBUART_EP1].addr & USBUART_DIR_IN))
                          {
                              /* Change source for descriptor 0. */
                              nextAddr = (uint32) USBUART_CyDmaGetSrcAddress(USBUART_EP1_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetSrcAddress(USBUART_EP1_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change source for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetSrcAddress(USBUART_EP1_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
                          else
                          {
                              /* Change destination for descriptor 0. */
                              nextAddr  = (uint32) USBUART_CyDmaGetDstAddress(USBUART_EP1_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetDstAddress(USBUART_EP1_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change destination for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetDstAddress(USBUART_EP1_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
              
                          /* Enable DMA to execute transfer as it was disabled because there were no valid descriptor. *
             -/
                          USBUART_CyDmaValidateDescriptor(USBUART_EP1_DMA_CH, USBUART_DMA_DESCR0);
                          USBUART_CyDmaChEnable (USBUART_EP1_DMA_CH);
                          USBUART_CyDmaTriggerIn(USBUART_DmaReqOut[USBUART_EP1]);
                      }
                  #endif /* (USBUART_DMA1_ACTIVE) */
              
              
                  #if (USBUART_DMA2_ACTIVE)
                      /******************************************************************************
                      * Function Name: USBUART_EP2_DMA_DONE_ISR
                      ***************************************************************************//**
                      *
                      *  Endpoint 2 DMA Done Interrupt Service Routine.
                      *
                      *
                      ******************************************************************************/
                      void USBUART_EP2_DMA_DONE_ISR(void)
                      {
                          uint32 nextAddr;
              
                          /* Manage data elements which remain to transfer. */
                          if (0u != USBUART_DmaEpBurstCnt[USBUART_EP2])
                          {
                              /* Decrement burst counter. */
                              --USBUART_DmaEpBurstCnt[USBUART_EP2];
                          }
                          else
                          {
                              /* Adjust length of last burst. */
                              USBUART_CyDmaSetNumDataElements(USBUART_EP2_DMA_CH,
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP2] >>
             - USBUART_DMA_DESCR_SHIFT),
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP2] & 
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 18  

             - USBUART_DMA_BURST_BYTES_MASK));
                          }
              
                          /* Advance source for input endpoint or destination for output endpoint. */
                          if (0u != (USBUART_EP[USBUART_EP2].addr & USBUART_DIR_IN))
                          {
                              /* Change source for descriptor 0. */
                              nextAddr = (uint32) USBUART_CyDmaGetSrcAddress(USBUART_EP2_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetSrcAddress(USBUART_EP2_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change source for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetSrcAddress(USBUART_EP2_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
                          else
                          {
                              /* Change destination for descriptor 0. */
                              nextAddr  = (uint32) USBUART_CyDmaGetDstAddress(USBUART_EP2_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetDstAddress(USBUART_EP2_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change destination for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetDstAddress(USBUART_EP2_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
              
                          /* Enable DMA to execute transfer as it was disabled because there were no valid descriptor. *
             -/
                          USBUART_CyDmaValidateDescriptor(USBUART_EP2_DMA_CH, USBUART_DMA_DESCR0);
                          USBUART_CyDmaChEnable (USBUART_EP2_DMA_CH);
                          USBUART_CyDmaTriggerIn(USBUART_DmaReqOut[USBUART_EP2]);
                      }
                  #endif /* (USBUART_DMA2_ACTIVE) */
              
              
                  #if (USBUART_DMA3_ACTIVE)
                      /******************************************************************************
                      * Function Name: USBUART_EP3_DMA_DONE_ISR
                      ***************************************************************************//**
                      *
                      *  Endpoint 3 DMA Done Interrupt Service Routine.
                      *
                      *
                      ******************************************************************************/
                      void USBUART_EP3_DMA_DONE_ISR(void)
                      {
                          uint32 nextAddr;
              
                          /* Manage data elements which remain to transfer. */
                          if (0u != USBUART_DmaEpBurstCnt[USBUART_EP3])
                          {
                              /* Decrement burst counter. */
                              --USBUART_DmaEpBurstCnt[USBUART_EP3];
                          }
                          else
                          {
                              /* Adjust length of last burst. */
                              USBUART_CyDmaSetNumDataElements(USBUART_EP3_DMA_CH,
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP3] >>
             - USBUART_DMA_DESCR_SHIFT),
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP3] & 
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 19  

             - USBUART_DMA_BURST_BYTES_MASK));
                          }
              
                          /* Advance source for input endpoint or destination for output endpoint. */
                          if (0u != (USBUART_EP[USBUART_EP3].addr & USBUART_DIR_IN))
                          {
                              /* Change source for descriptor 0. */
                              nextAddr = (uint32) USBUART_CyDmaGetSrcAddress(USBUART_EP3_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetSrcAddress(USBUART_EP3_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change source for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetSrcAddress(USBUART_EP3_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
                          else
                          {
                              /* Change destination for descriptor 0. */
                              nextAddr  = (uint32) USBUART_CyDmaGetDstAddress(USBUART_EP3_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetDstAddress(USBUART_EP3_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change destination for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetDstAddress(USBUART_EP3_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
              
                          /* Enable DMA to execute transfer as it was disabled because there were no valid descriptor. *
             -/
                          USBUART_CyDmaValidateDescriptor(USBUART_EP3_DMA_CH, USBUART_DMA_DESCR0);
                          USBUART_CyDmaChEnable (USBUART_EP3_DMA_CH);
                          USBUART_CyDmaTriggerIn(USBUART_DmaReqOut[USBUART_EP3]);
                      }
                  #endif /* (USBUART_DMA3_ACTIVE) */
              
              
                  #if (USBUART_DMA4_ACTIVE)
                      /******************************************************************************
                      * Function Name: USBUART_EP4_DMA_DONE_ISR
                      ***************************************************************************//**
                      *
                      *  Endpoint 4 DMA Done Interrupt Service Routine.
                      *
                      *
                      ******************************************************************************/
                      void USBUART_EP4_DMA_DONE_ISR(void)
                      {
                          uint32 nextAddr;
              
                          /* Manage data elements which remain to transfer. */
                          if (0u != USBUART_DmaEpBurstCnt[USBUART_EP4])
                          {
                              /* Decrement burst counter. */
                              --USBUART_DmaEpBurstCnt[USBUART_EP4];
                          }
                          else
                          {
                              /* Adjust length of last burst. */
                              USBUART_CyDmaSetNumDataElements(USBUART_EP4_DMA_CH,
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP4] >>
             - USBUART_DMA_DESCR_SHIFT),
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP4] & 
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 20  

             - USBUART_DMA_BURST_BYTES_MASK));
                          }
              
                          /* Advance source for input endpoint or destination for output endpoint. */
                          if (0u != (USBUART_EP[USBUART_EP4].addr & USBUART_DIR_IN))
                          {
                              /* Change source for descriptor 0. */
                              nextAddr = (uint32) USBUART_CyDmaGetSrcAddress(USBUART_EP4_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetSrcAddress(USBUART_EP4_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change source for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetSrcAddress(USBUART_EP4_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
                          else
                          {
                              /* Change destination for descriptor 0. */
                              nextAddr  = (uint32) USBUART_CyDmaGetDstAddress(USBUART_EP4_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetDstAddress(USBUART_EP4_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change destination for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetDstAddress(USBUART_EP4_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
              
                          /* Enable DMA to execute transfer as it was disabled because there were no valid descriptor. *
             -/
                          USBUART_CyDmaValidateDescriptor(USBUART_EP4_DMA_CH, USBUART_DMA_DESCR0);
                          USBUART_CyDmaChEnable (USBUART_EP4_DMA_CH);
                          USBUART_CyDmaTriggerIn(USBUART_DmaReqOut[USBUART_EP4]);
                      }
                  #endif /* (USBUART_DMA4_ACTIVE) */
              
              
                  #if (USBUART_DMA5_ACTIVE)
                      /******************************************************************************
                      * Function Name: USBUART_EP5_DMA_DONE_ISR
                      ***************************************************************************//**
                      *
                      *  Endpoint 5 DMA Done Interrupt Service Routine.
                      *
                      *
                      ******************************************************************************/
                      void USBUART_EP5_DMA_DONE_ISR(void)
                      {
                          uint32 nextAddr;
              
                          /* Manage data elements which remain to transfer. */
                          if (0u != USBUART_DmaEpBurstCnt[USBUART_EP5])
                          {
                              /* Decrement burst counter. */
                              --USBUART_DmaEpBurstCnt[USBUART_EP5];
                          }
                          else
                          {
                              /* Adjust length of last burst. */
                              USBUART_CyDmaSetNumDataElements(USBUART_EP5_DMA_CH,
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP5] >>
             - USBUART_DMA_DESCR_SHIFT),
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP5] & 
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 21  

             - USBUART_DMA_BURST_BYTES_MASK));
                          }
              
                          /* Advance source for input endpoint or destination for output endpoint. */
                          if (0u != (USBUART_EP[USBUART_EP5].addr & USBUART_DIR_IN))
                          {
                              /* Change source for descriptor 0. */
                              nextAddr = (uint32) USBUART_CyDmaGetSrcAddress(USBUART_EP5_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetSrcAddress(USBUART_EP5_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change source for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetSrcAddress(USBUART_EP5_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
                          else
                          {
                              /* Change destination for descriptor 0. */
                              nextAddr  = (uint32) USBUART_CyDmaGetDstAddress(USBUART_EP5_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetDstAddress(USBUART_EP5_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change destination for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetDstAddress(USBUART_EP5_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
              
                          /* Enable DMA to execute transfer as it was disabled because there were no valid descriptor. *
             -/
                          USBUART_CyDmaValidateDescriptor(USBUART_EP5_DMA_CH, USBUART_DMA_DESCR0);
                          USBUART_CyDmaChEnable (USBUART_EP5_DMA_CH);
                          USBUART_CyDmaTriggerIn(USBUART_DmaReqOut[USBUART_EP5]);
                      }
                  #endif /* (USBUART_DMA5_ACTIVE) */
              
              
                  #if (USBUART_DMA6_ACTIVE)
                      /******************************************************************************
                      * Function Name: USBUART_EP6_DMA_DONE_ISR
                      ***************************************************************************//**
                      *
                      *  Endpoint 6 DMA Done Interrupt Service Routine.
                      *
                      *
                      ******************************************************************************/
                      void USBUART_EP6_DMA_DONE_ISR(void)
                      {
                          uint32 nextAddr;
              
                          /* Manage data elements which remain to transfer. */
                          if (0u != USBUART_DmaEpBurstCnt[USBUART_EP6])
                          {
                              /* Decrement burst counter. */
                              --USBUART_DmaEpBurstCnt[USBUART_EP6];
                          }
                          else
                          {
                              /* Adjust length of last burst. */
                              USBUART_CyDmaSetNumDataElements(USBUART_EP6_DMA_CH,
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP6] >>
             - USBUART_DMA_DESCR_SHIFT),
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP6] & 
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 22  

             - USBUART_DMA_BURST_BYTES_MASK));
                          }
              
                          /* Advance source for input endpoint or destination for output endpoint. */
                          if (0u != (USBUART_EP[USBUART_EP6].addr & USBUART_DIR_IN))
                          {
                              /* Change source for descriptor 0. */
                              nextAddr = (uint32) USBUART_CyDmaGetSrcAddress(USBUART_EP6_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetSrcAddress(USBUART_EP6_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change source for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetSrcAddress(USBUART_EP6_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
                          else
                          {
                              /* Change destination for descriptor 0. */
                              nextAddr  = (uint32) USBUART_CyDmaGetDstAddress(USBUART_EP6_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetDstAddress(USBUART_EP6_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change destination for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetDstAddress(USBUART_EP6_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
              
                          /* Enable the DMA to execute transfer as it was disabled because there were no valid descripto
             -r. */
                          USBUART_CyDmaValidateDescriptor(USBUART_EP6_DMA_CH, USBUART_DMA_DESCR0);
                          USBUART_CyDmaChEnable (USBUART_EP6_DMA_CH);
                          USBUART_CyDmaTriggerIn(USBUART_DmaReqOut[USBUART_EP6]);
                      }
                  #endif /* (USBUART_DMA6_ACTIVE) */
              
              
                  #if (USBUART_DMA7_ACTIVE)
                      /******************************************************************************
                      * Function Name: USBUART_EP7_DMA_DONE_ISR
                      ***************************************************************************//**
                      *
                      *  Endpoint 7 DMA Done Interrupt Service Routine.
                      *
                      *
                      ******************************************************************************/
                      void USBUART_EP7_DMA_DONE_ISR(void)
                      {
                          uint32 nextAddr;
              
                          /* Manage data elements which remain to transfer. */
                          if (0u != USBUART_DmaEpBurstCnt[USBUART_EP7])
                          {
                              /* Decrement burst counter. */
                              --USBUART_DmaEpBurstCnt[USBUART_EP7];
                          }
                          else
                          {
                              /* Adjust length of last burst. */
                              USBUART_CyDmaSetNumDataElements(USBUART_EP7_DMA_CH,
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP7] >>
             - USBUART_DMA_DESCR_SHIFT),
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP7] & 
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 23  

             - USBUART_DMA_BURST_BYTES_MASK));
                          }
              
                          /* Advance source for input endpoint or destination for output endpoint. */
                          if (0u != (USBUART_EP[USBUART_EP7].addr & USBUART_DIR_IN))
                          {
                              /* Change source for descriptor 0. */
                              nextAddr = (uint32) USBUART_CyDmaGetSrcAddress(USBUART_EP7_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetSrcAddress(USBUART_EP7_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change source for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetSrcAddress(USBUART_EP7_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
                          else
                          {
                              /* Change destination for descriptor 0. */
                              nextAddr  = (uint32) USBUART_CyDmaGetDstAddress(USBUART_EP7_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetDstAddress(USBUART_EP7_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change destination for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetDstAddress(USBUART_EP7_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
              
                          /* Enable DMA to execute transfer as it was disabled because there were no valid descriptor. *
             -/
                          USBUART_CyDmaValidateDescriptor(USBUART_EP7_DMA_CH, USBUART_DMA_DESCR0);
                          USBUART_CyDmaChEnable (USBUART_EP7_DMA_CH);
                          USBUART_CyDmaTriggerIn(USBUART_DmaReqOut[USBUART_EP7]);
                      }
                  #endif /* (USBUART_DMA7_ACTIVE) */
              
              
                  #if (USBUART_DMA8_ACTIVE)
                      /******************************************************************************
                      * Function Name: USBUART_EP8_DMA_DONE_ISR
                      ***************************************************************************//**
                      *
                      *  Endpoint 8 DMA Done Interrupt Service Routine.
                      *
                      *
                      ******************************************************************************/
                      void USBUART_EP8_DMA_DONE_ISR(void)
                      {
                          uint32 nextAddr;
              
                          /* Manage data elements which remain to transfer. */
                          if (0u != USBUART_DmaEpBurstCnt[USBUART_EP8])
                          {
                              /* Decrement burst counter. */
                              --USBUART_DmaEpBurstCnt[USBUART_EP8];
                          }
                          else
                          {
                              /* Adjust length of last burst. */
                              USBUART_CyDmaSetNumDataElements(USBUART_EP8_DMA_CH,
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP8] >>
             - USBUART_DMA_DESCR_SHIFT),
                                                                      ((uint32) USBUART_DmaEpLastBurstEl[USBUART_EP8] & 
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 24  

             - USBUART_DMA_BURST_BYTES_MASK));
                          }
              
                          /* Advance source for input endpoint or destination for output endpoint. */
                          if (0u != (USBUART_EP[USBUART_EP8].addr & USBUART_DIR_IN))
                          {
                              /* Change source for descriptor 0. */
                              nextAddr = (uint32) USBUART_CyDmaGetSrcAddress(USBUART_EP8_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetSrcAddress(USBUART_EP8_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change source for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetSrcAddress(USBUART_EP8_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
                          else
                          {
                              /* Change destination for descriptor 0. */
                              nextAddr  = (uint32) USBUART_CyDmaGetDstAddress(USBUART_EP8_DMA_CH, USBUART_DMA_DESCR0);
                              nextAddr += (2u * USBUART_DMA_BYTES_PER_BURST);
                              USBUART_CyDmaSetDstAddress(USBUART_EP8_DMA_CH, USBUART_DMA_DESCR0, (void *) nextAddr);
              
                              /* Change destination for descriptor 1. */
                              nextAddr += USBUART_DMA_BYTES_PER_BURST;
                              USBUART_CyDmaSetDstAddress(USBUART_EP8_DMA_CH, USBUART_DMA_DESCR1, (void *) nextAddr);
                          }
              
                          /* Enable DMA to execute transfer as it was disabled because there were no valid descriptor. *
             -/
                          USBUART_CyDmaValidateDescriptor(USBUART_EP8_DMA_CH, USBUART_DMA_DESCR0);
                          USBUART_CyDmaChEnable (USBUART_EP8_DMA_CH);
                          USBUART_CyDmaTriggerIn(USBUART_DmaReqOut[USBUART_EP8]);
                      }
                  #endif /* (USBUART_DMA8_ACTIVE) */
              
              #else
                  #if (USBUART_EP_DMA_AUTO_OPT == 0u)
                      /******************************************************************************
                      * Function Name: USBUART_EP_DMA_DONE_ISR
                      ***************************************************************************//**
                      *
                      *  DMA Done Interrupt Service Routine.
                      *
                      *
                      ******************************************************************************/
                      CY_ISR(USBUART_EP_DMA_DONE_ISR)
                      {
                          uint8 int8Status;
                          uint8 int17Status;
                          uint8 ep_status;
                          uint8 ep = USBUART_EP1;
              
                      #ifdef USBUART_EP_DMA_DONE_ISR_ENTRY_CALLBACK
                          USBUART_EP_DMA_DONE_ISR_EntryCallback();
                      #endif /* (USBUART_EP_DMA_DONE_ISR_ENTRY_CALLBACK) */
              
                          /* `#START EP_DMA_DONE_BEGIN_USER_CODE` Place your code here */
              
                          /* `#END` */
              
                          /* Read clear on read status register with EP source of interrupt. */
                          int17Status = USBUART_EP17_DMA_Done_SR_Read() & USBUART_EP17_SR_MASK;
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 25  

                          int8Status  = USBUART_EP8_DMA_Done_SR_Read()  & USBUART_EP8_SR_MASK;
              
                          while (int8Status != 0u)
                          {
                              while (int17Status != 0u)
                              {
                                  if ((int17Status & 1u) != 0u)  /* If EpX interrupt present. */
                                  {
                                      /* Read Endpoint Status Register. */
                                      ep_status = USBUART_ARB_EP_BASE.arbEp[ep].epSr;
              
                                      if ((0u == (ep_status & USBUART_ARB_EPX_SR_IN_BUF_FULL)) &&
                                          (0u ==USBUART_inBufFull[ep]))
                                      {
                                          /* `#START EP_DMA_DONE_USER_CODE` Place your code here */
              
                                          /* `#END` */
              
                                      #ifdef USBUART_EP_DMA_DONE_ISR_CALLBACK
                                          USBUART_EP_DMA_DONE_ISR_Callback();
                                      #endif /* (USBUART_EP_DMA_DONE_ISR_CALLBACK) */
              
                                          /* Transfer again 2 last bytes into pre-fetch endpoint area. */
                                          USBUART_ARB_EP_BASE.arbEp[ep].rwWaMsb = 0u;
                                          USBUART_ARB_EP_BASE.arbEp[ep].rwWa = (USBUART_DMA_BYTES_PER_BURST * ep) - USBU
             -ART_DMA_BYTES_REPEAT;
                                          USBUART_LoadNextInEP(ep, 1u);
              
                                          /* Set Data ready status to generate DMA request. */
                                          USBUART_ARB_EP_BASE.arbEp[ep].epCfg |= USBUART_ARB_EPX_CFG_IN_DATA_RDY;
                                      }
                                  }
              
                                  ep++;
                                  int17Status >>= 1u;
                              }
              
                              int8Status >>= 1u;
              
                              if (int8Status != 0u)
                              {
                                  /* Prepare pointer for EP8. */
                                  ep = USBUART_EP8;
                                  int17Status = int8Status & 0x01u;
                              }
                          }
              
                          /* `#START EP_DMA_DONE_END_USER_CODE` Place your code here */
              
                          /* `#END` */
              
                  #ifdef USBUART_EP_DMA_DONE_ISR_EXIT_CALLBACK
                      USBUART_EP_DMA_DONE_ISR_ExitCallback();
                  #endif /* (USBUART_EP_DMA_DONE_ISR_EXIT_CALLBACK) */
                      }
                  #endif /* (USBUART_EP_DMA_AUTO_OPT == 0u) */
              #endif /* (CY_PSOC4) */
              #endif /* (USBUART_EP_MANAGEMENT_DMA_AUTO) */
1504          
1505          
1506          #if (CY_PSOC4)
                  /***************************************************************************
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 26  

                  * Function Name: USBUART_IntrHandler
                  ************************************************************************//**
                  *
                  *   Interrupt handler for Hi/Mid/Low ISRs.
                  *
                  *  regCause - The cause register of interrupt. One of the three variants:
                  *       USBUART_INTR_CAUSE_LO_REG - Low interrupts.
                  *       USBUART_INTR_CAUSE_MED_REG - Med interrupts.
                  *       USBUART_INTR_CAUSE_HI_REG - - High interrupts.
                  *
                  *
                  ***************************************************************************/
                  CY_INLINE static void USBUART_IntrHandler(uint32 intrCause)
                  {
                      /* Array of pointers to component interrupt handlers. */
                      static const cyisraddress USBUART_isrCallbacks[] =
                      {
              
                      };
              
                      uint32 cbIdx = 0u;
              
                      /* Check arbiter interrupt source first. */
                      if (0u != (intrCause & USBUART_INTR_CAUSE_ARB_INTR))
                      {
                          USBUART_isrCallbacks[USBUART_ARB_EP_INTR_NUM]();
                      }
              
                      /* Check all other interrupt sources (except arbiter and resume). */
                      intrCause = (intrCause  & USBUART_INTR_CAUSE_CTRL_INTR_MASK) |
                                  ((intrCause & USBUART_INTR_CAUSE_EP1_8_INTR_MASK) >>
                                                USBUART_INTR_CAUSE_EP_INTR_SHIFT);
              
                      /* Call interrupt handlers for active interrupt sources. */
                      while (0u != intrCause)
                      {
                          if (0u != (intrCause & 0x1u))
                          {
                               USBUART_isrCallbacks[cbIdx]();
                          }
              
                          intrCause >>= 1u;
                          ++cbIdx;
                      }
                  }
              
              
                  /***************************************************************************
                  * Function Name: USBUART_INTR_HI_ISR
                  ************************************************************************//**
                  *
                  *   Interrupt Service Routine for the high group of the interrupt sources.
                  *
                  *
                  ***************************************************************************/
                  CY_ISR(USBUART_INTR_HI_ISR)
                  {
                      USBUART_IntrHandler(USBUART_INTR_CAUSE_HI_REG);
                  }
              
                  /***************************************************************************
                  * Function Name: USBUART_INTR_MED_ISR
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 27  

                  ************************************************************************//**
                  *
                  *   Interrupt Service Routine for the medium group of the interrupt sources.
                  *
                  *
                  ***************************************************************************/
                  CY_ISR(USBUART_INTR_MED_ISR)
                  {
                     USBUART_IntrHandler(USBUART_INTR_CAUSE_MED_REG);
                  }
              
                  /***************************************************************************
                  * Function Name: USBUART_INTR_LO_ISR
                  ************************************************************************//**
                  *
                  *   Interrupt Service Routine for the low group of the interrupt sources.
                  *
                  *
                  ***************************************************************************/
                  CY_ISR(USBUART_INTR_LO_ISR)
                  {
                      USBUART_IntrHandler(USBUART_INTR_CAUSE_LO_REG);
                  }
              #endif /* (CY_PSOC4) */
1594          
1595          
1596          /* [] END OF FILE */
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 28  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION USBUART_EP_1_ISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
0006 C085              PUSH    DPH1
0008 C084              PUSH    DPL1
000A C086              PUSH    DPS
000C 758600            MOV     DPS,#00H
000F C000        E     PUSH    ?C?XPAGE1SFR
0011 750000      E     MOV     ?C?XPAGE1SFR,#?C?XPAGE1RST
0014 C0D0              PUSH    PSW
0016 75D000            MOV     PSW,#00H
0019 C006              PUSH    AR6
001B C007              PUSH    AR7
                                           ; SOURCE LINE # 37
                                           ; SOURCE LINE # 55
001D 90600B            MOV     DPTR,#0600BH
0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
0022 EF                MOV     A,R7
0023 54FE              ANL     A,#0FEH
0025 FF                MOV     R7,A
0026 EF                MOV     A,R7
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 64
                                           ; SOURCE LINE # 66
0028 90600E            MOV     DPTR,#0600EH
002B E0                MOVX    A,@DPTR
002C FF                MOV     R7,A
                                           ; SOURCE LINE # 69
002D 900000      E     MOV     DPTR,#USBUART_EP+0BH
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
0032 EF                MOV     A,R7
0033 5403              ANL     A,#03H
0035 FF                MOV     R7,A
0036 7E00              MOV     R6,#00H
0038 EF                MOV     A,R7
0039 6401              XRL     A,#01H
003B 4E                ORL     A,R6
003C 600E              JZ      ?C0004
                                           ; SOURCE LINE # 70
                                           ; SOURCE LINE # 71
003E 900000      E     MOV     DPTR,#USBUART_EP+0EH
0041 E0                MOVX    A,@DPTR
0042 FF                MOV     R7,A
0043 EF                MOV     A,R7
0044 6480              XRL     A,#080H
0046 FF                MOV     R7,A
0047 900000      E     MOV     DPTR,#USBUART_EP+0EH
004A EF                MOV     A,R7
004B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 72
004C         ?C0004:
                                           ; SOURCE LINE # 80
004C 900000      E     MOV     DPTR,#USBUART_EP+0CH
004F 7401              MOV     A,#01H
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 81
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 29  

                                           ; SOURCE LINE # 107
0052 D007              POP     AR7
0054 D006              POP     AR6
0056 D0D0              POP     PSW
0058 D000        E     POP     ?C?XPAGE1SFR
005A D086              POP     DPS
005C D084              POP     DPL1
005E D085              POP     DPH1
0060 D082              POP     DPL
0062 D083              POP     DPH
0064 D0E0              POP     ACC
0066 32                RETI    
             ; FUNCTION USBUART_EP_1_ISR (END)

             ; FUNCTION USBUART_EP_2_ISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
0006 C085              PUSH    DPH1
0008 C084              PUSH    DPL1
000A C086              PUSH    DPS
000C 758600            MOV     DPS,#00H
000F C000        E     PUSH    ?C?XPAGE1SFR
0011 750000      E     MOV     ?C?XPAGE1SFR,#?C?XPAGE1RST
0014 C0D0              PUSH    PSW
0016 75D000            MOV     PSW,#00H
0019 C006              PUSH    AR6
001B C007              PUSH    AR7
                                           ; SOURCE LINE # 120
                                           ; SOURCE LINE # 137
001D 90600B            MOV     DPTR,#0600BH
0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
0022 EF                MOV     A,R7
0023 54FD              ANL     A,#0FDH
0025 FF                MOV     R7,A
0026 EF                MOV     A,R7
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 146
                                           ; SOURCE LINE # 148
0028 90601E            MOV     DPTR,#0601EH
002B E0                MOVX    A,@DPTR
002C FF                MOV     R7,A
                                           ; SOURCE LINE # 151
002D 900000      E     MOV     DPTR,#USBUART_EP+016H
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
0032 EF                MOV     A,R7
0033 5403              ANL     A,#03H
0035 FF                MOV     R7,A
0036 7E00              MOV     R6,#00H
0038 EF                MOV     A,R7
0039 6401              XRL     A,#01H
003B 4E                ORL     A,R6
003C 600E              JZ      ?C0009
                                           ; SOURCE LINE # 152
                                           ; SOURCE LINE # 153
003E 900000      E     MOV     DPTR,#USBUART_EP+019H
0041 E0                MOVX    A,@DPTR
0042 FF                MOV     R7,A
0043 EF                MOV     A,R7
0044 6480              XRL     A,#080H
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 30  

0046 FF                MOV     R7,A
0047 900000      E     MOV     DPTR,#USBUART_EP+019H
004A EF                MOV     A,R7
004B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 154
004C         ?C0009:
                                           ; SOURCE LINE # 162
004C 900000      E     MOV     DPTR,#USBUART_EP+017H
004F 7401              MOV     A,#01H
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 163
                                           ; SOURCE LINE # 189
0052 D007              POP     AR7
0054 D006              POP     AR6
0056 D0D0              POP     PSW
0058 D000        E     POP     ?C?XPAGE1SFR
005A D086              POP     DPS
005C D084              POP     DPL1
005E D085              POP     DPH1
0060 D082              POP     DPL
0062 D083              POP     DPH
0064 D0E0              POP     ACC
0066 32                RETI    
             ; FUNCTION USBUART_EP_2_ISR (END)

             ; FUNCTION USBUART_EP_3_ISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
0006 C085              PUSH    DPH1
0008 C084              PUSH    DPL1
000A C086              PUSH    DPS
000C 758600            MOV     DPS,#00H
000F C000        E     PUSH    ?C?XPAGE1SFR
0011 750000      E     MOV     ?C?XPAGE1SFR,#?C?XPAGE1RST
0014 C0D0              PUSH    PSW
0016 75D000            MOV     PSW,#00H
0019 C006              PUSH    AR6
001B C007              PUSH    AR7
                                           ; SOURCE LINE # 201
                                           ; SOURCE LINE # 218
001D 90600B            MOV     DPTR,#0600BH
0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
0022 EF                MOV     A,R7
0023 54FB              ANL     A,#0FBH
0025 FF                MOV     R7,A
0026 EF                MOV     A,R7
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 227
                                           ; SOURCE LINE # 229
0028 90602E            MOV     DPTR,#0602EH
002B E0                MOVX    A,@DPTR
002C FF                MOV     R7,A
                                           ; SOURCE LINE # 232
002D 900000      E     MOV     DPTR,#USBUART_EP+021H
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
0032 EF                MOV     A,R7
0033 5403              ANL     A,#03H
0035 FF                MOV     R7,A
0036 7E00              MOV     R6,#00H
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 31  

0038 EF                MOV     A,R7
0039 6401              XRL     A,#01H
003B 4E                ORL     A,R6
003C 600E              JZ      ?C0014
                                           ; SOURCE LINE # 233
                                           ; SOURCE LINE # 234
003E 900000      E     MOV     DPTR,#USBUART_EP+024H
0041 E0                MOVX    A,@DPTR
0042 FF                MOV     R7,A
0043 EF                MOV     A,R7
0044 6480              XRL     A,#080H
0046 FF                MOV     R7,A
0047 900000      E     MOV     DPTR,#USBUART_EP+024H
004A EF                MOV     A,R7
004B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 235
004C         ?C0014:
                                           ; SOURCE LINE # 243
004C 900000      E     MOV     DPTR,#USBUART_EP+022H
004F 7401              MOV     A,#01H
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 244
                                           ; SOURCE LINE # 270
0052 D007              POP     AR7
0054 D006              POP     AR6
0056 D0D0              POP     PSW
0058 D000        E     POP     ?C?XPAGE1SFR
005A D086              POP     DPS
005C D084              POP     DPL1
005E D085              POP     DPH1
0060 D082              POP     DPL
0062 D083              POP     DPH
0064 D0E0              POP     ACC
0066 32                RETI    
             ; FUNCTION USBUART_EP_3_ISR (END)

             ; FUNCTION USBUART_SOF_ISR (BEGIN)
                                           ; SOURCE LINE # 693
                                           ; SOURCE LINE # 703
                                           ; SOURCE LINE # 708
0000 32                RETI    
             ; FUNCTION USBUART_SOF_ISR (END)

             ; FUNCTION USBUART_BUS_RESET_ISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C085              PUSH    DPH1
000A C084              PUSH    DPL1
000C C086              PUSH    DPS
000E 758600            MOV     DPS,#00H
0011 C000        E     PUSH    ?C?XPAGE1SFR
0013 750000      E     MOV     ?C?XPAGE1SFR,#?C?XPAGE1RST
0016 C0D0              PUSH    PSW
0018 75D000            MOV     PSW,#00H
001B C000              PUSH    AR0
001D C001              PUSH    AR1
001F C002              PUSH    AR2
0021 C003              PUSH    AR3
0023 C004              PUSH    AR4
0025 C005              PUSH    AR5
C51 COMPILER V9.51   USBUART_EPISR                                                         04/28/2016 18:59:27 PAGE 32  

0027 C006              PUSH    AR6
0029 C007              PUSH    AR7
                                           ; SOURCE LINE # 722
                                           ; SOURCE LINE # 732
                                           ; SOURCE LINE # 734
002B 120000      E     LCALL   USBUART_ReInitComponent
                                           ; SOURCE LINE # 739
002E D007              POP     AR7
0030 D006              POP     AR6
0032 D005              POP     AR5
0034 D004              POP     AR4
0036 D003              POP     AR3
0038 D002              POP     AR2
003A D001              POP     AR1
003C D000              POP     AR0
003E D0D0              POP     PSW
0040 D000        E     POP     ?C?XPAGE1SFR
0042 D086              POP     DPS
0044 D084              POP     DPL1
0046 D085              POP     DPH1
0048 D082              POP     DPL
004A D083              POP     DPH
004C D0F0              POP     B
004E D0E0              POP     ACC
0050 32                RETI    
             ; FUNCTION USBUART_BUS_RESET_ISR (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    391    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
